% crochet

open purr.ide.ui;
open crochet.concurrency;
open crochet.debug;

type application-configure(project is purr-project) is purr-application;

command application-configure title = "Configure";
command application-configure icon = #widget icon: "cog";
command application-configure description = "View and update the configuration of your project";

enum application-configure-pages =
  meta-data,
  capabilities;

command application-configure render-application do
  #widget tabbed-panel: [
    #tab id: "meta-data"
      | header: "Basic information"
      | content: self basic-info,

    #tab id: "crochet"
      | header: "Crochet package"
      | content: self crochet-package,
  ]
  | layout: #tabbed-panel-layout vertical-left
  | selected: "meta-data"
  | commit;
end

command application-configure title: Title actions: Actions body: Body do
  #widget flex-column: [
    #widget flex-row: [
      pui heading-2: Title
        | transform
        | flex-grow: #flex-grow grow,
      (Actions as widget)
        | transform
        | width: #size fit-content,
    ]
    | transform
    | flex-align-items: #flex-align baseline
    | flex-justify-content: #flex-justify space-between,
    Body,
  ]
  | transform
  | flex-gap: #text-size base
  | padding-horizontal: #text-size large-2x
  | padding-vertical: #text-size base
  | height: #size fit-content; 
end

command application-configure crochet-package do
  let Project = purr current-project;
  let Name = #reference text-input: "name";
  let Target = #reference select-one: "target";
  let Initial = #observable-cell with-value: [
                 name -> Project value meta name,
                 target -> Project value meta target
               ];
  Project stream subscribe: { X in Initial <- [name -> X meta name, target -> X meta target] };

  let Form = (Name validated-value zip: Target selected with: { N, T in N map: { N in [name -> N, target -> T] }});
  let Raw-form = Name value zip: Target selected with: { N, T in [name -> N, target -> T] };
  let Has-changes = Raw-form zip: Initial with: { A, B in not (A =:= B) };
  let Is-valid = Form map: { X in X is ok };

  self
    title: "Crochet package"
    actions: (
      #widget flex-row: [
        #widget icon-button: (#widget icon: "undo")
          | on-click: { _ in Initial <- Initial value }
          | transform
          | visible: Has-changes,

        #widget icon-button: (#widget icon: "check")
          | on-click: { _ in
              Form value
                | map: { X in
                    purr update-project: (
                      Project value changeset
                        | meta: { M in M name: X.name | target: X.target }
                    )
                  }
                | recover: { _ in
                    purr show-modal: "Could not update the project meta-data.";
                  }
            }
          | transform
          | font-color: #color green-800
          | visible: (Has-changes zip: Is-valid with: (_ and _)),
      ]
      | transform
      | flex-gap: (1.0 as root-em)
    )
    body: (
      #widget flex-column: [
        #widget flex-column: [
          #widget text-input: "Name"
            | value: (Initial map: { X in X.name })
            | placeholder: "name.your.project"
            | validation: { X in
                #crochet-package try-parse-name: X
                  | map-error: { _ in 
                      #widget flex-column: [
                        "
                        Name segments must start with a lowercase letter ('a' to 'z'),
                        and may only contain lowercase letters, digits ('0' to '9'),
                        and hyphens ('-'). A name can be made out of multiple segments
                        separated by a dot ('.');
                        ",
                        "
                        E.g.: 'name.your.project'
                        "
                      ]
                    }
              }
            | reference: Name,
          pui secondary-text: "
            The name uniquely identifies your package. It's conventionally
            written in a 'reverse domain' form. For example, if you own
            a domain like 'cute-games.com', and are working on a project
            called 'Sweetz', your name could be 'com.cute-games.sweetz'.
          "
            | transform
            | font-size: #text-size small
        ]
        | transform
        | flex-gap: (0.5 as root-em),

        #widget flex-column: [
          #widget select-one: "Target platform"
            | options: [
                #select-option label: "Any platform" value: #crochet-package-target any,
                #select-option label: "Web Browsers" value: #crochet-package-target browser,
                #select-option label: "Node.js" value: #crochet-package-target node,
              ]
            | selected: (Initial map: { X in X.target })
            | reference: Target,
          pui secondary-text: "
            The platforms that your package aims to (or is known to) work on. 'Any Platform'
            means that your package does not use any platform-specific feature, and can run
            anywhere Crochet does.
          "
            | transform
            | font-size: #text-size small,
        ]
        | transform
        | flex-gap: (0.5 as root-em),
      ]
      | transform
      | flex-gap: (1.5 as root-em)
    );
end

command application-configure basic-info do
  let Title = #reference text-input: "title";
  let Description = #reference text-input: "description";
  let Project = purr current-project;

  self
    title: "Basic information"
    actions: #widget space
    body: (
      #widget flex-row: [
        #widget flex-column: [
          #widget text-input: "Title"
            | value: (Project map: { X in X title })
            | placeholder: "Your Great Project"
            | reference: Title,

          #widget text-input: "Description"
            | value: (Project map: { X in X description})
            | placeholder: "Does this and that and that other thing"
            | reference: Description,
        ]
        | transform
        | flex-gap: (1.5 as root-em),

        #widget flex-column: [
          ("Cover image" as widget)
            | transform
            | font-weight: #font-weight medium,

          #widget flex-column: [
            (Project map: { X in self render-cover: X cover }) as widget
              | transform
              | width: #size fill
          ]
          | transform
          | background-color: #color neutral-900
          | width: #size fill
          | aspect-ratio: (#aspect-ratio width: 16 height: 9)
          | border-radius: #border-radius rounded
          | overflow: #overflow hidden
          | flex-align-items: #flex-align center
          | flex-justify-content: #flex-justify stretch
          | border: #line-size pixel style: #border-style solid color: #color border,
          
          Project map: { X in self cover-image-actions: X cover }
        ]
        | transform
        | flex-gap: (0.5 as root-em),
      ]
      | transform
      | flex-gap: (3.0 as root-em)
    );
end

command application-configure cover-image-actions: (X is error) =
  pui action-button: "Add cover image"
    |> _ icon: "images"
    |> _ as widget
    |> _ transform
    |> _ width: #size fill;

command application-configure cover-image-actions: (X is ok) =
  #widget flex-column: [
    pui action-button: "Add cover image"
      | icon: "images",

    pui action-button: "Remove cover image"
      | icon: "times"
  ]
  | transform
  | flex-gap: (0.5 as root-em);

command application-configure render-cover: (X is error) =
  #widget space;

command application-configure render-cover: (X is ok) =
  #widget image: (package assets at: "assets/a.png");



command application-configure capabilities do
  self
    title: "Capabilities"
    actions: #widget space
    body: (
      #widget tabbed-panel: [
        #tab id: "requested"
          | header: "Requested"
          | content: self requested-capabilities,
        
        #tab id: "provided"
          | header: "Provided"
          | content: self provided-capabilities,
      ]
      | selected: "requested"
    );
end

command application-configure requested-capabilities do
  let Capabilities = purr current-project map: { X in X meta capabilities };
  let Required = Capabilities map: { X in X strictly-required };
  let Optional = Capabilities map: { X in X optional };
  let Trusted = Capabilities map: { X in X trusted };

  #widget flex-column: [
    self capability-section: "Required"
        description: "The package needs these capabilities to run."
        items: Required,

    self capability-section: "Optional"
        description: "The package can use these capabilities to provide additional features."
        items: Optional,

    self capability-section: "Trusted"
        description: "The package will be granted these capabilities automatically when
                      included as part of Crochet's Trusted Computing Base (standard library)."
        items: Trusted,
  ]
  | transform
  | padding-vertical: (1.0 as root-em);
end

command application-configure capability-section: Title description: Desc items: Items-cell do
  Items-cell map: { Items in 
    condition
      when Items is-empty => [];
      otherwise =>
        #widget card: [
          #card-child header: (
            #widget flex-column: [
              Title,
              (Desc as widget)
                | transform
                | font-size: #text-size small
            ]
          ),
          #card-child body: (
            #widget flex-column: (Items map: (pui requested-capability: _))
              | flex-gap: (1.0 as root-em)
          )
        ]
        | style: #card-style fluid
        | transform
        | margin-bottom: (2.0 as root-em);
    end
  };
end

command application-configure provided-capabilities do
  "";
end