% crochet

open crochet.language.json;
open crochet.language.pickles;
open crochet.text.regex;

type crochet-package(meta is any);

// Parsing and serialisation
define package-parser = lazy (
  pickles from-schema: (package assets at: "assets/package.pickles" | read-as-text)
    | lookup-module: "package"
    | lookup: "Package"
);

command #crochet-package try-parse: (Json is text) -> result<crochet-package, any> do
  json try-parse: Json
    | then: { X in (force package-parser) parse: X }
    | map: { X in new crochet-package(X) };
end

command crochet-package serialise =
  self.meta;

// Changesets
type crochet-package-changeset(
  from is crochet-package,
  changes is list<crochet-package-change>,
) is purr-changeset;

abstract crochet-package-change is purr-change;
type crochet-package-change--name(value is text) is crochet-package-change;
type crochet-package-change--target(value is crochet-package-target) is crochet-package-change;
type crochet-package-change--stability(value is crochet-package-stability) is crochet-package-change;


command crochet-package-change--name apply: (P is crochet-package) =
  #change-result compare: P.meta.name and: self.value then: {
    #change-result
      updated: new crochet-package(P with meta -> [P.meta with name -> self.value])
      audit-log: [
        path -> "name",
        value -> self.value,
      ];
  };

command crochet-package-change--stability apply: (P is crochet-package) =
  #change-result compare: P.meta.stability and: self.value then: {
    #change-result
      updated: new crochet-package(P with meta -> [P.meta with stability -> self.value to-enum-text])
      audit-log: [
        path -> "stability",
        value -> self.value,
      ];
  };

command crochet-package-change--target apply: (P is crochet-package) =
  #change-result compare: P.meta.target and: self.value then: {
    #change-result
      updated: new crochet-package(P with meta -> [P.meta with target -> self.value to-enum-text])
      audit-log: [
        path -> "target",
        value -> self.value to-enum-text,
      ];
  };

command crochet-package changeset =
  new crochet-package-changeset(
    from -> self,
    changes -> [],
  );

command crochet-package-changeset append: (X is crochet-package-change) =
  new crochet-package-changeset(self with changes -> self.changes append: X);

command crochet-package-changeset name: (Value is text) =
  self append: new crochet-package-change--name(Value);

command crochet-package-changeset target: (Target is crochet-package-target) =
  self append: new crochet-package-change--target(Target);


// Types and accessors
enum crochet-package-stability = 
  experimental, stable, frozen, deprecated, unknown;

enum crochet-package-target =
  any, browser, node;

command crochet-package name = self.meta.name;
command crochet-package title = self.meta.title;
command crochet-package description = self.meta.description;

command crochet-package target =
  #crochet-package-target from-enum-text: self.meta.target;

command crochet-package stability =
  #crochet-package-stability from-enum-text: self.meta.stability;

command crochet-package capabilities =
  new crochet-package-capabilities(self.meta.capabilities);


type crochet-package-capabilities(meta is any);

enum crochet-capability-risk =
  low, medium, high, critical, unknown;

enum crochet-capability-kind =
  required, optional, trusted;

command crochet-package-capabilities requested =
  self.meta.requested
    | map: { X in new crochet-package-requested-capability(X) };

command crochet-package-capabilities provided =
  self.meta.provided
    | map: { X in new crochet-package-provided-capability(X) };

command crochet-package-capabilities strictly-required =
  self requested keep-if: { X in X kind === #crochet-capability-kind required };

command crochet-package-capabilities optional =
  self requested keep-if: { X in X kind === #crochet-capability-kind optional };

command crochet-package-capabilities trusted =
  self requested keep-if: { X in X kind === #crochet-capability-kind trusted };

command crochet-package-capabilities user-grantable =
  self strictly-required ++ self optional;


type crochet-package-requested-capability(meta is any);

command crochet-package-requested-capability name =
  self.meta.name;

command crochet-package-requested-capability reason =
  self.meta.reason;

command crochet-package-requested-capability kind =
  #crochet-capability-kind from-enum-text: self.meta.kind;


type crochet-package-provided-capability(meta is any);

command crochet-package-provided-capability name =
  self.meta.name;

command crochet-package-provided-capability title =
  self.meta.title;

command crochet-package-provided-capability description =
  self.meta.description;

command crochet-package-provided-capability risk =
  #crochet-capability-risk from-enum-text: self.meta.risk;


// Name validation
local define package-name-re = lazy (
  regex from-text: "^\[a-z\]\[a-z0-9\\-\]*(?:\\.\[a-z\]\[a-z0-9\\-\]*)*$"
    | compile
);

type crochet-package-error-invalid-name(name is unsafe-arbitrary-text);

command #crochet-package try-parse-name: (Name is unsafe-arbitrary-text) do
  let Re = force package-name-re;
  Re search-first: Name
    | map: (_ matched-text)
    | map-error: { _ in new crochet-package-error-invalid-name(Name) };
end