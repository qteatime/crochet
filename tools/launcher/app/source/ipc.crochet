% crochet

open crochet.language.json;
local singleton module;

// IPC machinery
command #purr-ipc setup: (Block is (() -> nothing)) do
  let IPC-cell = #cell with-value: new purr-ipc([->]);
  handle
    module setup-listener: IPC-cell;
    Block();
  with
    on purr-ipc.add-client(Id, Client) do
      let IPC = IPC-cell value;
      IPC-cell <- new purr-ipc(IPC.clients at: Id put: Client);
      foreign dom.install-hidden-frame(Client.frame.box);
      continue with nothing;
    end

    on purr-ipc.get-instance() do
      continue with IPC-cell value;
    end
  end
end

command #purr-ipc shared-instance =
  perform purr-ipc.get-instance();

command purr-ipc add-client: (Project is purr-project) frame: (Frame is dom-window) do
  let Client = new purr-ipc-client(Project.id, Frame);
  let Actor = new actor-ipc(#cell with-value: [], Client, actor-ipc-loading, false);
  perform purr-ipc.add-client(Project.id, Actor);
  Client;
end

command module setup-listener: IPC-cell do
  foreign dom.on-message({ Msg0 in 
    let Msg = #json parse: Msg0;
    let Id = Msg.id;
    let IPC = IPC-cell value;
    let Client = IPC client-for-id: Id;
    Client dispatch: (IPC parse-message: Msg);
  });  
end

command purr-ipc client-for-id: Id =
  self.clients at: Id;

command purr-ipc parse-message: (Message is record) do
  let Method = Message.method;
  let Data = Message.data;
  condition
    when Method === "ready" => im-ready;
    when Method === "ready-for-testing" => im-ready-for-testing;
    when Method === "testing-started" => im-testing-started;
  end
end

command purr-ipc-client serialise-message: imo-spawn-testing =
  [ 
    method -> "spawn-testing",
    id -> self.id,
    data -> [->],
  ];

command purr-ipc serialise-message: imo-run-tests =
  [
    method -> "run-tests",
    id -> self.id,
    data -> [->]
  ];

command purr-ipc-client dispatch: (X is ipc-outgoing) do
  let Message = self serialise-message: X;
  foreign dom.post-message(self.frame, Message);
  self;
end

// IPC messages
command purr-ipc-client spawn-tests =
  self dispatch: imo-spawn-testing;

command purr-ipc-client run-tests =
  self dispatch: imo-run-tests;

// IPC handlers
command actor-ipc dispatch: (Message is ipc-incoming) do
  self store-message: Message;
  condition
    when not self.busy value do
      self dispatch-next;
    end

    otherwise do nothing end
  end
end

command actor-ipc store-mesage: Message do
  self.message-box <- self.message-box value append: Message;
end

command actor-ipc select-message do
  let State = self.state value;
  let Message-box = self.message-box value;
  let Message = Mesage-box find: (State accepts: _);
  self.message-box <- Message-box without: { X in X =:= Message };
  Message;
end

command actor-ipc dispatch-next do
  let Message = self select-message;
  condition
    when Message is ipc-incoming do
      self.busy <- true;
      self handle: Message;
      self.busy <- false;
      self dispatch-next;
    end

    otherwise do nothing end
  end
end

command actor-ipc handle: Message do
  let Result = self.state value handle: Message;
  self handle-result: Result;
end

command actor-ipc handle-result: mhr-done do nothing end;

command actor-ipc handle-result: (S is mhr-transition) do
  self.state <- S.new-state;
end

command actor-ipc-state accepts: _ = false;

command actor-ipc-loading accepts: im-ready = true;
command actor-ipc-loading handle: im-ready =
  new mhr-transition(actor-ipc-ready);

command actor-ipc-waiting-for-test accepts: im-ready-for-testing = true;
command actor-ipc-waiting-for-test handle: im-ready-for-testing =
  new mhr-transition(actor-ipc-ready-for-test);

command actor-ipc-testing accepts: im-test-result = true;
command actor-ipc-testing handle: (X is im-test-result) do
  self.results <- self.results value append: X.result;
end