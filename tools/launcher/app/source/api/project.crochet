% crochet

open crochet.text.regex;

local singleton module;

command purr-project id =
  self.id;

command purr-project-meta name =
  self.metadata.name;

command purr-project-meta title =
  self.metadata
    | at: "title" default: self name;

command purr-project-meta description =
  self.metadata
    | at: "description" default: "(no description)";

command purr-project-meta stability =
  self.metadata
    | at: "stability" default: "(not defined)";

command purr-project-meta target =
  self.metadata
    | at: "target" default: "*";

command purr-project-meta capabilities do
  let Cap = self.metadata at: "capabilities" default: [->];
  let Required = Cap at: "requires" default: [];
  let Provided = Cap at: "provides" default: [];

  new purr-package-capabilities(
    Required map: { X in module parse-capability: X },
    Provided map: { X in module parse-capability: X }
  );
end

command purr-project-meta dependencies do
  let Deps = self.metadata at: "dependencies" default: [];
  for Dep in Deps do module parse-dependency: Dep end;
end

command purr-project-meta packaging-targets do
  let Target = self.metadata at: "target" default: "*";
  condition
    when Target === "node" => [pt-node];
    when Target === "browser" => [pt-browser];
    when Target === "*" => [pt-node, pt-browser];
  end
end

command module parse-dependency: (X is text) do
  new purr-dependency(X, "*", []);
end

command module parse-dependency: (X is record) do
  new purr-dependency(
    X.name,
    X at: "target" default: "*",
    module parse-capabilities: (X at: "capabilities" default: [])
  )
end

command module parse-capabilities: Xs do
  for C in Xs do module parse-capability: C end
end

command module parse-capability: (X is text) do
  module parse-capability: [name -> X, description -> "(no description)"];
end

command module parse-capability: (X is record) do
  let Valid-name = regex from-text: "^(?:[a-z][a-z0-9\-\.]*/)?[a-z][a-z0-9\-]*$" | compile;
  condition
    when Valid-name can-match: X.name =>
      new purr-valid-capability(
        name -> X.name,
        description -> X at: "description" default: "(no description)"
      );

    otherwise =>
      new purr-invalid-capability(
        name -> "(invalid)",
        description -> X at: "description" default: "(no description)",
        original-name -> X.name
      );
  end
end

command purr-project missing-capabilities: (Grants is set<text>) do
  self required-capabilities
    | remove-if: (Grants contains: _);
end

command purr-project required-capabilities do
  self meta capabilities required
    |> _ keep-if: { C in C is purr-valid-capability }
    |> _ map: (_ name)
    |> #set from: _;
end