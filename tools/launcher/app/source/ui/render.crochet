% crochet

local singleton module;

command dom-renderer render: (X is w-container) do
  let Children = for N in X.children do (self render: N).box end;
  new dom-node(foreign dom.container(X.tag, X.class, Children));
end

command dom-renderer render: (X is w-style) do
  self render: new w-container("div", X.class, X.children);
end

command dom-renderer render: (X is w-icon) do
  new dom-node(foreign dom.icon(X.name));
end

command dom-renderer render: (X is w-text) do
  new dom-node(foreign dom.text(X.contents));
end

command dom-renderer render: (X is w-button) do
  let Handler = { Ev in X.on-click(new dom-event(Ev)) };
  let Children = for N in X.children do (self render: N).box end;
  new dom-node(foreign dom.button(X.title, Handler, Children));
end

command dom-renderer render: (X is w-action-button) do
  self render: new w-style(
    "agata-action-button",
    [
      new w-button(
        X.title,
        X.on-click,
        [
          new w-icon(X.icon),
          new w-container("div", "agata-action-text", [
            new w-container("div", "agata-action-text-title", [
              new w-text(X.title)
            ]),
            new w-container("div", "agata-action-text-description", [
              new w-text(X.description)
            ])
          ])
        ]
      )
    ]
  );
end

command dom-renderer render: (X is w-icon-button) do
  self render: new w-style(
    "agata-icon-button",
    [
      new w-button(
        X.title,
        X.on-click,
        [
          new w-icon(X.icon)
        ]
      )
    ]
  );
end

command dom-renderer render: (X is w-tabbed-panel) do
  let Children = for N in X.tabs do self render: N end;
  new dom-node(foreign dom.tabbed-panel(Children));
end

command dom-renderer render: (X is wn-tab) do
  let Children = for N in X.contents do (self render: N).box end;
  [X.title, Children];
end

command dom-renderer render: (X is w-flex-column) do
  self render: new w-container("div", "agata-flex-column", X.children);
end

command dom-renderer render: (X is w-flex-row) do
  self render: new w-container("div", "agata-flex-row", X.children);
end

command dom-renderer render: (X is w-layout) do
  let Node = self render: X.child;
  let Box = Node.box;
  for Property in X.layout pairs do
    let Value = self to-css: Property value;
    foreign dom.set-style(Property key, Value, Box);
  end
  Node
end

command dom-renderer render: (X is w-frame) do
  new dom-node(foreign dom.container("div", "agata-frame", [
    X.window.box
  ]));
end

open crochet.debug;

command dom-renderer render: (X is w-dynamic) do
  let Node = foreign dom.container("div", "agata-dynamic", []);
  let Canvas = new dom-dynamic-canvas(X);
  handle
    X.renderer(Canvas);
  with
    on agata-canvas.replace(Contents) do
      foreign dom.render(Node, Contents.box);
      continue with nothing;
    end

    on agata-canvas.append(Contents) do
      foreign dom.append(Node, Contents.box);
      continue with nothing;
    end

    on agata-canvas.prepend(Contents) do
      foreign dom.prepend(Node, Contents.box);
      continue with nothing;
    end
  end
  new dom-node(Node);
end

command dom-renderer render: (X is w-switch) do
  let Node = new w-dynamic({ Canvas in
    X.observable subscribe: { Value in
      let Case = X.cases find: { C in C.guard(Value) }
                   | value-or-panic: "No suitable cases";
      let Widget = Case.handler(Value);
      Canvas render: Widget;
    } capture;
  });
  self render: Node;
end

command dom-renderer render: (X has to-widget) do
  self render: (X as widget);
end

command dom-renderer render: (X is w-observable) do
  let Node = new w-dynamic({ Canvas in
    Canvas render: (X.observable value);
    X.observable subscribe: { V in Canvas render: V } capture;
  });
  self render: Node;
end

command dom-renderer render: (X is w-observable-stream) do
  let Node = new w-dynamic({ Canvas in
    X.observable subscribe: { V in Canvas append: V } capture;
  });
  self render: Node;
end

command dom-renderer render: (X is w-code-editor) do
  let Result = foreign dom.code-editor(X.read-only, X.code, X.on-commit);
  new dom-node-code-editor(Result.node, Result.monaco);
end

command dom-renderer render: (X is w-text-input) do
  new dom-node-input(foreign dom.input("text", X.read-only, X.value, X.placeholder));
end

command dom-renderer render: (X is w-label) do
  let Input = self render: X.input;
  new dom-node(foreign dom.label(X.label, Input.box));
end

command dom-renderer render: (X is w-reference) do
  let Node = self render: X.child;
  perform agata-presentation.register-reference(X.reference, Node);
  Node;
end

command dom-renderer render: (X is w-fragment) do
  let Children = for N in X.children do (self render: N).box end;
  let Node = foreign dom.fragment(Children);
  new dom-node(Node);
end

command dom-renderer render: (X is w-committed) =
  X.render;

command dom-renderer render: (X is w-focus) do
  let Node = self render: X.widget;
  module setup-focus: Node;
  Node;
end

command dom-renderer render: (X is w-modal-progress) do
  let Nodes = foreign dom.modal-container("agata-modal-progress");
  let Node = new dom-modal-progress(Nodes.root, Nodes.label);
  let Child = self render: X.child-builder(Node);
  foreign dom.render(Nodes.container, Child.box);
  new dom-node(Nodes.root);
end

command module setup-focus: (X is dom-node-code-editor) do
  foreign dom.setup-monaco-focus(X.box, X.monaco);
end

command module setup-focus: (X is dom-node-input) do
  foreign dom.setup-focus(X.box);
end

command module setup-focus: dom-node do
  nothing
end

command dom-renderer to-css: (P is gap) =
  "[self to-css: P.horizontal] [self to-css: P.vertical]" flatten-into-plain-text;

command dom-renderer to-css: (M is pixels) =
  "[M.value to-text]px" flatten-into-plain-text;

command dom-renderer to-css: (M is percent) =
  "[M.value to-text]%" flatten-into-plain-text;

command dom-renderer to-css: (M is em) =
  "[M.value to-text]em" flatten-into-plain-text;

command dom-renderer to-css: (X is text) =
  X;

command dom-renderer to-css: (X is numeric) =
  X to-text;

command dom-canvas render: (Node is dom-node) do
  foreign dom.render(self.box, Node.box);
  self;
end


command reference-env at: Key do
  let Mapping = self.mapping value;
  condition
    when Mapping contains-key: Key => #result ok: (Mapping at: Key);
    when not (self.parent is nothing) => self.parent at: Key;
    otherwise => #result error: not-found;
  end
end

command reference-env at: Key put: Value do
  self.mapping <- self.mapping value at: Key put: Value;
  self;
end