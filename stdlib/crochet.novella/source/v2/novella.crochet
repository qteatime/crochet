% crochet

singleton novella;

effect novella-action with
  say(text is nvl-text); // -> nothing
  clear(layer is nvl-layer); // -> nothing
  menu(menu is nvl-menu<A>); // -> A
end

type nvl-size(global width is integer, global height is integer);

singleton nvl-dom;
type nvl-dom-node(box is unknown);

type nvl-layer(name is text, transform is nvl-transform);
type nvl-layer-group(layers is list<nvl-layer>, global dialogue is nvl-layer, global menu is nvl-layer);

abstract nvl-renderer;
type nvl-web-renderer-config(root is nvl-dom-node, size is nvl-size, global layers is nvl-layer-group) is nvl-renderer;

type nvl-web-renderer(
  config is nvl-web-renderer-config,
  screen is nvl-dom-node,
  layer-map is map<nvl-layer, nvl-dom-node>,
);

type nvl-menu(items is list<nvl-menu-item>);

abstract nvl-menu-item;
type nvl-menu-leaf(label is text, value is A) is nvl-menu-item;
type nvl-menu-branch(prefix is text, items is list<nvl-menu-item>) is nvl-menu-item;

abstract nvl-unit;
type nvl-unit-pixel(value is integer) is nvl-unit;
type nvl-unit-percent(value is float-64bit) is nvl-unit;


type nvl-transform(properties is list<nvl-property>);

abstract nvl-property;
type nvl-dimension(width is nvl-unit, height is nvl-unit) is nvl-property;
type nvl-position(x is nvl-unit, y is nvl-unit) is nvl-property;
type nvl-padding(top is nvl-unit, right is nvl-unit, bottom is nvl-unit, left is nvl-unit) is nvl-property;


abstract nvl-element;
type nvl-text(children is list<nvl-text-component>) is nvl-element;

abstract nvl-text-component;
type nvl-tc-text(content is text) is nvl-text-component;
type nvl-tc-strong(child is nvl-text-component) is nvl-text-component;
type nvl-tc-emphasis(child is nvl-text-component) is nvl-text-component;
type nvl-tc-flow(children is list<nvl-text-component>) is nvl-text-component;

trait to-nvl-text-component with
  command Self as nvl-text-component -> nvl-text-component;
end

trait to-nvl-text with
  command Self as nvl-text -> nvl-text;
end


implement to-nvl-text for text;
command text as nvl-text =
  new nvl-text([self as nvl-text-component]);

implement to-nvl-text for interpolation;
command interpolation as nvl-text =
  new nvl-text([self as nvl-text-component]);

implement to-nvl-text-component for text;
command text as nvl-text-component =
  new nvl-tc-text(self);

implement to-nvl-text-component for interpolation;
command interpolation as nvl-text-component =
  new nvl-tc-flow(self parts map: (_ as nvl-text-component));


command #nvl-menu items: (Items is list<nvl-menu-item>) =
  new nvl-menu(Items);

command #nvl-menu-leaf label: (Label is text) value: Value =
  new nvl-menu-leaf(Label, Value);

command #nvl-menu-branch label: (Label is text) items: (Items is list<nvl-menu-item>) =
  new nvl-menu-branch(Label, Items);


command #nvl-size zero =
  new nvl-size(width -> 0, height -> 0);

command #nvl-size width: (W is integer) height: (H is integer)
requires
  non-negative :: (W >= 0) and (H >= 0)
=
  new nvl-size(width -> W, height -> H);


command #nvl-layer-group defaults do
  let Dialogue = new nvl-layer(name -> "dialogue", transform -> #nvl-transform empty);
  let Menu = new nvl-layer(name -> "menu", transform -> #nvl-transform empty);
  new nvl-layer-group(
    layers -> [
      Dialogue,
      Menu,
    ],
    dialogue -> Dialogue,
    menu -> Menu,
  );
end

command #nvl-layer-group layers: (Layers is list<nvl-layer>) dialogue: (Dialogue is nvl-layer) menu: (Menu is nvl-layer) =
  new nvl-layer-group(Layers, Dialogue, Menu);


command novella web-renderer: (Root is unknown)
requires
  html-element :: nvl-dom is-element: Root
do
  new nvl-web-renderer-config(
    root -> nvl-dom from-html-element: Root,
    size -> #nvl-size zero,
    layers -> #nvl-layer-group defaults
  );
end

command nvl-web-renderer-config width: W height: H =
  new nvl-web-renderer-config(self with size -> #nvl-size width: W height: H);

command nvl-web-renderer-config layers: (Layers is nvl-layer-group) =
  new nvl-web-renderer-config(self with layers -> Layers);

command nvl-web-renderer-config setup do
  let W = self.size width to-text;
  let H = self.size height to-text;
  let Screen = nvl-dom make: "div" class: "novella-screen"
                | set-style: [
                    width -> "[W]px" flatten-into-plain-text,
                    height -> "[H]px" flatten-into-plain-text,
                    aspect-ratio -> "[W] / [H]" flatten-into-plain-text
                  ];
  let Layer-map = (self layers).layers fold-from: #map empty with: { Map, Layer in
    let Layer-node = nvl-dom make: "div" class: "novella-layer"
                      | set: "data-name" to: Layer.name;
    Screen append: Layer-node;
    Map at: Layer put: Layer-node;
  };
  self.root append: Screen;
  let Renderer = new nvl-web-renderer(
    config -> self,
    screen -> Screen,
    layer-map -> Layer-map
  );
  for Layer in Layer-map entries do
    Renderer transform: Layer value with: (Layer key).transform;
  end
  Renderer;
end

command nvl-web-renderer clear-at: (Layer is nvl-layer) do
  let Node = self.layer-map at: Layer;
  Node remove-contents;
  self;
end

command nvl-web-renderer at: (Layer is nvl-layer) show: (Node is nvl-dom-node) do
  let Layer-node = self.layer-map at: Layer;
  Layer-node append: Node;
  self;
end

command nvl-web-renderer wait-text-interaction: (Node is nvl-dom-node) do
  let Continue-mark = nvl-dom make: "span" class: "novella-continue-marker";
  Node append: Continue-mark;
  nvl-dom wait-interaction;
  Continue-mark detach;
  self;
end


command novella say: (Text has to-nvl-text) =
  perform novella-action.say(Text as nvl-text);

command novella clear: (Layer is nvl-layer) =
  perform novella-action.clear(Layer);

command novella menu: (Menu is nvl-menu) =
  perform novella-action.menu(Menu);


handler novella-game renderer: (Config is nvl-renderer) do
  let Renderer = Config setup;
  let Dialogue-layer = Config layers dialogue;
  let Menu-layer = Config layers menu;
with
  on novella-action.say(Text) do
    let Node = Renderer render: Text;
    Renderer at: Dialogue-layer show: Node;
    Renderer wait-text-interaction: Node;
    continue with nothing;
  end

  on novella-action.clear(Layer) do
    Renderer clear-at: Layer;
    continue with nothing;
  end

  on novella-action.menu(Menu) do
    let Menu-data = Renderer render-menu: Menu;
    let Layer-node = Renderer.layer-map at: Menu-layer;
    let Result = foreign dom.show-menu("I", Layer-node.box, Menu-data);
    Renderer clear-at: Menu-layer;
    continue with Result;
  end
end


command nvl-dom make: (Tag is text) class: (Class is text) =
  new nvl-dom-node(foreign dom.make(Tag, Class));

command nvl-dom make-text: (Text is text) =
  new nvl-dom-node(foreign dom.text(Text));

command nvl-dom from-html-element: (Node is unknown)
requires
  is-element :: nvl-dom is-element: Node
=
  new nvl-dom-node(Node);

command nvl-dom is-element: (X is unknown) =
  foreign dom.is-element(X);

command nvl-dom-node set: (Attr is text) to: (Value is text) do
  foreign dom.set(self.box, Attr, Value);
  self;
end

command nvl-dom-node set-style: (Style is record) do
  foreign dom.set-style(self.box, Style);
  self;
end

command nvl-dom-node append: (Node is nvl-dom-node) do
  foreign dom.append(self.box, Node.box);
  self;
end

command nvl-dom-node remove-contents do
  foreign dom.clear(self.box);
  self;
end

command nvl-dom-node detach
requires attached :: foreign dom.is-attached(self.box)
do
  foreign dom.detach(self.box);
  self;
end

command nvl-dom wait-interaction do
  foreign dom.wait-interaction();
  self;
end


command nvl-web-renderer render: (X is nvl-text) do
  let Node = nvl-dom make: "div" class: "novella-text";
  for Child in X.children do
    Node append: (self render: Child);
  end
  Node;
end

command nvl-web-renderer render: (X is nvl-tc-text) do
  nvl-dom make-text: X.content;
end

command nvl-web-renderer render: (X is nvl-tc-strong) do
  nvl-dom make: "strong" class: "novella-text-strong"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-emphasis) do
  nvl-dom make: "em" class: "novella-text-emphasis"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-flow) do
  let Node = nvl-dom make: "span" class: "novella-text-flow";
  for Child in X.children do
    Node append: (self render: Child);
  end
  Node;
end

command nvl-web-renderer render-menu-item: (X is nvl-menu-leaf) =
  foreign dom.make-menu-leaf(X.label, X.value);

command nvl-web-renderer render-menu-item: (X is nvl-menu-branch) =
  foreign dom.make-menu-branch(X.prefix, X.items map: (self render-menu-item: _));

command nvl-web-renderer render-menu: (X is nvl-menu) do
  let Items = X.items map: (self render-menu-item: _);
  foreign dom.make-menu(Items);
end

command nvl-web-renderer transform: (X is nvl-dom-node) with: (T is nvl-transform) do
  for Property in T.properties do
    self apply-property: Property to: X;
  end
  X;
end

command nvl-web-renderer apply-property: (X is nvl-dimension) to: (N is nvl-dom-node) =
  N set-style: [
    width -> self render-unit: X.width,
    height -> self render-unit: X.height,
  ];

command nvl-web-renderer apply-property: (X is nvl-position) to: (N is nvl-dom-node) =
  N set-style: [
    left -> self render-unit: X.x,
    top -> self render-unit: X.y,
  ];

command nvl-web-renderer apply-property: (X is nvl-padding) to: (N is nvl-dom-node) =
  N set-style: [
    padding-top -> self render-unit: X.top,
    padding-right -> self render-unit: X.right,
    padding-bottom -> self render-unit: X.bottom,
    padding-left -> self render-unit: X.left,
  ];

command nvl-web-renderer render-unit: (X is nvl-unit-pixel) =
  "[X.value to-text]px" flatten-into-plain-text;

command nvl-web-renderer render-unit: (X is nvl-unit-percent) =
  "[X.value to-text]%" flatten-into-plain-text;


command #nvl-unit pixels: (X is integer) =
  new nvl-unit-pixel(X);

command #nvl-unit percent: (X is integer) =
  new nvl-unit-percent(X as float-64bit);

command #nvl-unit percent: (X is float-64bit) =
  new nvl-unit-percent(X);



command #nvl-dimension width: (W is nvl-unit) height: (H is nvl-unit) =
  new nvl-dimension(W, H);

command #nvl-position x: (X is nvl-unit) y: (Y is nvl-unit) =
  new nvl-position(X, Y);

command #nvl-padding zero =
  new nvl-padding(
    top -> #nvl-unit pixels: 0,
    bottom -> #nvl-unit pixels: 0,
    left -> #nvl-unit pixels: 0,
    right -> #nvl-unit pixels: 0,
  );

command nvl-padding top: (X is nvl-unit) =
  new nvl-padding(self with top -> X);

command nvl-padding bottom: (X is nvl-unit) =
  new nvl-padding(self with bottom -> X);

command nvl-padding left: (X is nvl-unit) =
  new nvl-padding(self with left -> X);

command nvl-padding right: (X is nvl-unit) =
  new nvl-padding(self with right -> X);

command nvl-padding vertical: (X is nvl-unit) =
  self top: X | bottom: X;

command nvl-padding horizontal: (X is nvl-unit) =
  self left: X | right: X;

command nvl-padding all: (X is nvl-unit) =
  self horizontal: X | vertical: X;


command #nvl-transform empty =
  new nvl-transform([]);

command #nvl-transform with: (Props is list<nvl-property>) =
  new nvl-transform(Props);


command #nvl-layer name: (Name is text) =
  new nvl-layer(name -> Name, transform -> #nvl-transform empty);

command nvl-layer transform: (Transform is nvl-transform) =
  new nvl-layer(self with transform -> Transform);