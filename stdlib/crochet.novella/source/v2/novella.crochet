% crochet

singleton novella;

effect novella-action with
  wait-interaction(layer is nvl-layer); // -> nothing
  show(item is nvl-element, layer is nvl-layer); // -> nothing
  say(text is nvl-text, layer is nvl-layer); // -> nothing
  menu(menu is nvl-menu<A>, layer is nvl-layer); // -> A
  clear(layer is nvl-layer); // -> nothing
  get-layers(); // -> nvl-layer-group
end

type nvl-size(global width is integer, global height is integer);

singleton nvl-dom;
type nvl-dom-node(box is unknown);

type nvl-layer(name is text, transform is nvl-transform);
type nvl-layer-group(
  layers is list<nvl-layer>,
  global dialogue is nvl-layer,
  global title is nvl-layer,
  global background is nvl-layer,
);

abstract nvl-renderer;
type nvl-web-renderer-config(root is nvl-dom-node, size is nvl-size, global layers is nvl-layer-group) is nvl-renderer;

type nvl-web-renderer(
  config is nvl-web-renderer-config,
  screen is nvl-dom-node,
  layer-map is map<nvl-layer, nvl-dom-node>,
);

type nvl-menu(items is list<nvl-menu-item>);

abstract nvl-menu-item;
type nvl-menu-leaf(label is text, value is A) is nvl-menu-item;
type nvl-menu-branch(prefix is text, items is list<nvl-menu-item>) is nvl-menu-item;

abstract nvl-unit;
type nvl-unit-pixel(value is integer) is nvl-unit;
type nvl-unit-percent(value is float-64bit) is nvl-unit;


type nvl-transform(properties is list<nvl-property>);

abstract nvl-property;
type nvl-dimension(width is nvl-unit, height is nvl-unit) is nvl-property;
type nvl-position(x is nvl-unit, y is nvl-unit) is nvl-property;
type nvl-padding(top is nvl-unit, right is nvl-unit, bottom is nvl-unit, left is nvl-unit) is nvl-property;


abstract nvl-element;
type nvl-text(children is list<nvl-text-component>) is nvl-element;
type nvl-image(source is nvl-source) is nvl-element;
type nvl-transform-element(element is nvl-element, transform is nvl-transform) is nvl-element;

abstract nvl-source;
type nvl-source-asset(asset is package-asset) is nvl-source;

abstract nvl-text-component;
type nvl-tc-text(content is text) is nvl-text-component;
type nvl-tc-strong(child is nvl-text-component) is nvl-text-component;
type nvl-tc-emphasis(child is nvl-text-component) is nvl-text-component;
type nvl-tc-italic(child is nvl-text-component) is nvl-text-component;
type nvl-tc-bold(child is nvl-text-component) is nvl-text-component;
type nvl-tc-flow(children is list<nvl-text-component>) is nvl-text-component;

trait to-nvl-text-component with
  command Self as nvl-text-component -> nvl-text-component;
end

trait to-nvl-text with
  command Self as nvl-text -> nvl-text;
end

trait to-nvl-element with
  command Self as nvl-element -> nvl-element;
end


implement to-nvl-text for text;
command text as nvl-text =
  new nvl-text([self as nvl-text-component]);

implement to-nvl-text for interpolation;
command interpolation as nvl-text =
  new nvl-text([self as nvl-text-component]);

implement to-nvl-text for nvl-text-component;
command nvl-text-component as nvl-text =
  new nvl-text([self]);

implement to-nvl-text-component for text;
command text as nvl-text-component =
  new nvl-tc-text(self);

implement to-nvl-text-component for interpolation;
command interpolation as nvl-text-component =
  new nvl-tc-flow(self parts map: (_ as nvl-text-component));

implement to-nvl-text-component for nvl-text-component;
command nvl-text-component as nvl-text-component =
  self;

implement to-nvl-element for text;
command text as nvl-element =
  self as nvl-text;

implement to-nvl-element for interpolation;
command interpolation as nvl-element =
  self as nvl-text;

implement to-nvl-element for nvl-text-component;
command nvl-text-component as nvl-element =
  self as nvl-text;

implement to-nvl-element for nvl-element;
command nvl-element as nvl-element =
  self;

command #nvl-text strong: (X has to-nvl-text-component) =
  new nvl-tc-strong(X as nvl-text-component);

command #nvl-text emphasis: (X has to-nvl-text-component) =
  new nvl-tc-emphasis(X as nvl-text-component);

command #nvl-text italic: (X has to-nvl-text-component) =
  new nvl-tc-italic(X as nvl-text-component);

command #nvl-text bold: (X has to-nvl-text-component) =
  new nvl-tc-bold(X as nvl-text-component);

command #nvl-text flow: (Xs is list<X has to-nvl-text-component>) =
  new nvl-tc-flow(Xs map: (_ as nvl-text-component));


command #nvl-menu items: (Items is list<nvl-menu-item>) =
  new nvl-menu(Items);

command #nvl-menu-leaf label: (Label is text) value: Value =
  new nvl-menu-leaf(Label, Value);

command #nvl-menu-branch label: (Label is text) items: (Items is list<nvl-menu-item>) =
  new nvl-menu-branch(Label, Items);

command package menu-item: (X is nvl-menu-leaf) accepts: (Prefix is text) =
  X.label =:= Prefix;

command package menu-item: (X is nvl-menu-branch) accepts: (Prefix is text) =
  X.prefix =:= Prefix;

command package menu-items: (Items is list<nvl-menu-item>) insert: (Parts is list<text>) value: Value do
  let Part = Parts first;
  Items
    | enumerate
    | find-first: { X in package menu-item: X value accepts: Part }
    | map: { X in
        X value insert: Parts value: Value
          |> Items at: X index put: _
      }
    | value-or-else: { _ in 
        #nvl-menu-branch label: Part items: []
          |> _ insert: Parts value: Value
          |> Items append: _
      };
end

command nvl-menu insert: (Parts is list<text>) value: Value do
  new nvl-menu(self with items -> package menu-items: self.items insert: Parts value: Value);
end

command nvl-menu-branch insert: (Parts is list<text>) value: Value
requires
  empty-if-leaf :: do condition
                     when Parts is-empty => true;
                     when Parts count =:= 1 => (Parts first =:= self.prefix) and self.items is-empty;
                     otherwise => (Parts first =:= self.prefix);
                   end end
do
  condition
    when Parts is-empty =>
      self;

    when Parts count =:= 1 =>
      #nvl-menu-leaf label: Parts first value: Value;

    otherwise =>
      new nvl-menu-branch(self with items -> package menu-items: self.items insert: Parts rest value: Value);
  end
end

command nvl-menu-leaf insert: (Parts is list<text>) value: Value
requires
  non-duplicate :: condition
                    when Parts is-empty => true;
                    when Parts count =:= 1 => (Parts first =:= self.label) and (Value =:= self.value);
                    otherwise => false;
                   end
do
  self;
end

command nvl-menu flatten-menu-tree =
  new nvl-menu(self with items -> self.items map: (_ flatten-menu-tree));

command nvl-menu-leaf flatten-menu-tree =
  self;

command nvl-menu-branch flatten-menu-tree do
  condition
    when self.items count === 1 do
      let Item = self.items first flatten-menu-tree;
      condition
        when Item is nvl-menu-leaf do
          let Label = "[self.prefix][Item.label]" flatten-into-plain-text;
          #nvl-menu-leaf label: Label value: Item.value;
        end

        otherwise =>
          new nvl-menu-branch(self with items -> [Item]);
      end
    end

    otherwise =>
      new nvl-menu-branch(self with items -> self.items map: (_ flatten-menu-tree));
  end
end


command #nvl-size zero =
  new nvl-size(width -> 0, height -> 0);

command #nvl-size width: (W is integer) height: (H is integer)
requires
  non-negative :: (W >= 0) and (H >= 0)
=
  new nvl-size(width -> W, height -> H);


command #nvl-layer-group defaults do
  let Dialogue = new nvl-layer(name -> "dialogue", transform -> #nvl-transform empty);
  let Background = new nvl-layer(name -> "background", transform -> #nvl-transform empty);
  let Title = new nvl-layer(name -> "title", transform -> #nvl-transform empty);
  new nvl-layer-group(
    layers -> [
      Background,
      Title,
      Dialogue,
    ],
    dialogue -> Dialogue,
    background -> Background,
    title -> Title,
  );
end

command novella web-renderer: (Root is unknown)
requires
  html-element :: nvl-dom is-element: Root
do
  new nvl-web-renderer-config(
    root -> nvl-dom from-html-element: Root,
    size -> #nvl-size zero,
    layers -> #nvl-layer-group defaults
  );
end

command nvl-web-renderer-config width: W height: H =
  new nvl-web-renderer-config(self with size -> #nvl-size width: W height: H);

command nvl-web-renderer-config layers: (Layers is nvl-layer-group) =
  new nvl-web-renderer-config(self with layers -> Layers);

command nvl-web-renderer-config setup do
  let W = self.size width to-text;
  let H = self.size height to-text;
  let Screen = nvl-dom make: "div" class: "novella-screen"
                | set-style: [
                    width -> "[W]px" flatten-into-plain-text,
                    height -> "[H]px" flatten-into-plain-text,
                    aspect-ratio -> "[W] / [H]" flatten-into-plain-text
                  ];
  let Layer-map = (self layers).layers fold-from: #map empty with: { Map, Layer in
    let Layer-node = nvl-dom make: "div" class: "novella-layer"
                      | set: "data-name" to: Layer.name;
    Screen append: Layer-node;
    Map at: Layer put: Layer-node;
  };
  self.root add-class: "novella-root";
  self.root append: Screen;
  let Renderer = new nvl-web-renderer(
    config -> self,
    screen -> Screen,
    layer-map -> Layer-map
  );
  for Layer in Layer-map entries do
    Renderer transform: Layer value with: (Layer key).transform;
  end
  Renderer;
end

command nvl-web-renderer clear-at: (Layer is nvl-layer) do
  let Node = self.layer-map at: Layer;
  Node remove-contents;
  self;
end

command nvl-web-renderer at: (Layer is nvl-layer) show: (Node is nvl-dom-node) do
  let Layer-node = self.layer-map at: Layer;
  Layer-node append: Node;
  self;
end

command nvl-web-renderer wait-text-interaction: (Node is nvl-dom-node) do
  let Continue-mark =
    nvl-dom make: "span" class: "novella-continue-marker"
      | append: (nvl-dom make: "span" class: "novella-continue-marker-help"
                  | append: (nvl-dom make-text: "(click or press 'Return' to continue)"))
      | append: (nvl-dom make: "i" class: "novella-continue-marker-icon fas fa-chevron-down");
  Node append: Continue-mark;
  nvl-dom wait-interaction;
  Continue-mark detach;
  self;
end


command novella say: Text =
  novella at: novella layers dialogue say: Text;

command novella at: (Layer is nvl-layer) say: (Text has to-nvl-text) =
  perform novella-action.say(Text as nvl-text, Layer);

command novella at: (Layer is nvl-layer) show: (X has to-nvl-element) =
  perform novella-action.show(X as nvl-element, Layer);

command novella clear: (Layer is nvl-layer) =
  perform novella-action.clear(Layer);

command novella menu: Menu =
  novella at: novella layers dialogue menu: Menu;

command novella at: (Layer is nvl-layer) menu: (Menu is nvl-menu) =
  perform novella-action.menu(Menu, Layer);

command novella wait-interaction =
  novella wait-interaction-at: novella layers dialogue;

command novella wait-interaction-at: (Layer is nvl-layer) =
  perform novella-action.wait-interaction(Layer);

command package action-title-parts: (Title is interpolation) =
  Title parts;

command package action-title-parts: (Title is text) =
  [Title];

command novella choose-action: (Actions is list<action-choice>) do
  Actions fold-from: new nvl-menu([]) with: { Menu, Action in
    let Parts = package action-title-parts: Action title | map: (_ to-text);
    Menu insert: Parts value: Action;
  }
  |> novella menu: _;
end

command novella layers =
  perform novella-action.get-layers();


handler novella-game renderer: (Config is nvl-renderer) do
  let Renderer = Config setup;
with
  on novella-action.say(Text, Layer) do
    let Node = Renderer render: Text;
    Renderer at: Layer show: Node;
    continue with nothing;
  end

  on novella-action.wait-interaction(Layer) do
    let Layer-node = Renderer.layer-map at: Layer;
    Renderer wait-text-interaction: Layer-node;
    continue with nothing;
  end

  on novella-action.show(Element, Layer) do
    let Node = Renderer render: Element;
    Renderer at: Layer show: Node;
    continue with nothing;
  end

  on novella-action.clear(Layer) do
    Renderer clear-at: Layer;
    continue with nothing;
  end

  on novella-action.menu(Menu, Layer) do
    let Menu-data = Renderer render-menu: Menu;
    let Layer-node = Renderer.layer-map at: Layer;
    let Result = foreign dom.show-menu("I", Layer-node.box, Menu-data);
    continue with Result;
  end

  on novella-action.get-layers() do
    continue with Config layers;
  end
end


command nvl-dom make: (Tag is text) class: (Class is text) =
  new nvl-dom-node(foreign dom.make(Tag, Class));

command nvl-dom make-text: (Text is text) =
  new nvl-dom-node(foreign dom.text(Text));

command nvl-dom from-html-element: (Node is unknown)
requires
  is-element :: nvl-dom is-element: Node
=
  new nvl-dom-node(Node);

command nvl-dom is-element: (X is unknown) =
  foreign dom.is-element(X);

command nvl-dom-node set: (Attr is text) to: (Value is text) do
  foreign dom.set(self.box, Attr, Value);
  self;
end

command nvl-dom-node set-style: (Style is record) do
  foreign dom.set-style(self.box, Style);
  self;
end

command nvl-dom-node add-class: (Name is text) do
  foreign dom.add-class(self.box, Name);
  self;
end

command nvl-dom-node append: (Node is nvl-dom-node) do
  foreign dom.append(self.box, Node.box);
  self;
end

command nvl-dom-node remove-contents do
  foreign dom.clear(self.box);
  self;
end

command nvl-dom-node detach
requires attached :: foreign dom.is-attached(self.box)
do
  foreign dom.detach(self.box);
  self;
end

command nvl-dom wait-interaction do
  foreign dom.wait-interaction();
  self;
end


command nvl-web-renderer render: (X is nvl-text) do
  let Node = nvl-dom make: "div" class: "novella-text";
  for Child in X.children do
    Node append: (self render: Child);
  end
  Node;
end

command nvl-web-renderer render: (X is nvl-tc-text) do
  nvl-dom make-text: X.content;
end

command nvl-web-renderer render: (X is nvl-tc-strong) do
  nvl-dom make: "strong" class: "novella-text-strong"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-emphasis) do
  nvl-dom make: "em" class: "novella-text-emphasis"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-bold) do
  nvl-dom make: "b" class: "novella-text-bold"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-italic) do
  nvl-dom make: "i" class: "novella-text-italic"
    | append: (self render: X.child);
end

command nvl-web-renderer render: (X is nvl-tc-flow) do
  let Node = nvl-dom make: "span" class: "novella-text-flow";
  for Child in X.children do
    Node append: (self render: Child);
  end
  Node;
end

command nvl-web-renderer render: (X is nvl-transform-element) do
  let Node = self render: X.element;
  self transform: Node with: X.transform;
end

command nvl-web-renderer render: (X is nvl-image) do
  let Uri = self resolve-source-uri: X.source;
  nvl-dom make: "img" class: "novella-image"
    | set: "src" to: Uri;
end

command nvl-web-renderer resolve-source-uri: (Source is nvl-source-asset) =
  asset-location resolve: Source.asset;

command nvl-web-renderer render-menu-item: (X is nvl-menu-leaf) =
  foreign dom.make-menu-leaf(X.label, X.value);

command nvl-web-renderer render-menu-item: (X is nvl-menu-branch) =
  foreign dom.make-menu-branch(X.prefix, X.items map: (self render-menu-item: _));

command nvl-web-renderer render-menu: (X is nvl-menu) do
  let Items = X.items map: (self render-menu-item: _);
  foreign dom.make-menu(Items);
end

command nvl-web-renderer transform: (X is nvl-dom-node) with: (T is nvl-transform) do
  for Property in T.properties do
    self apply-property: Property to: X;
  end
  X;
end

command nvl-web-renderer apply-property: (X is nvl-dimension) to: (N is nvl-dom-node) =
  N set-style: [
    width -> self render-unit: X.width,
    height -> self render-unit: X.height,
  ];

command nvl-web-renderer apply-property: (X is nvl-position) to: (N is nvl-dom-node) =
  N set-style: [
    left -> self render-unit: X.x,
    top -> self render-unit: X.y,
  ];

command nvl-web-renderer apply-property: (X is nvl-padding) to: (N is nvl-dom-node) =
  N set-style: [
    padding-top -> self render-unit: X.top,
    padding-right -> self render-unit: X.right,
    padding-bottom -> self render-unit: X.bottom,
    padding-left -> self render-unit: X.left,
  ];

command nvl-web-renderer render-unit: (X is nvl-unit-pixel) =
  "[X.value to-text]px" flatten-into-plain-text;

command nvl-web-renderer render-unit: (X is nvl-unit-percent) =
  "[X.value to-text]%" flatten-into-plain-text;


command #nvl-unit pixels: (X is integer) =
  new nvl-unit-pixel(X);

command #nvl-unit percent: (X is integer) =
  new nvl-unit-percent(X as float-64bit);

command #nvl-unit percent: (X is float-64bit) =
  new nvl-unit-percent(X);



command #nvl-dimension width: (W is nvl-unit) height: (H is nvl-unit) =
  new nvl-dimension(W, H);

command #nvl-position x: (X is nvl-unit) y: (Y is nvl-unit) =
  new nvl-position(X, Y);

command #nvl-padding zero =
  new nvl-padding(
    top -> #nvl-unit pixels: 0,
    bottom -> #nvl-unit pixels: 0,
    left -> #nvl-unit pixels: 0,
    right -> #nvl-unit pixels: 0,
  );

command nvl-padding top: (X is nvl-unit) =
  new nvl-padding(self with top -> X);

command nvl-padding bottom: (X is nvl-unit) =
  new nvl-padding(self with bottom -> X);

command nvl-padding left: (X is nvl-unit) =
  new nvl-padding(self with left -> X);

command nvl-padding right: (X is nvl-unit) =
  new nvl-padding(self with right -> X);

command nvl-padding vertical: (X is nvl-unit) =
  self top: X | bottom: X;

command nvl-padding horizontal: (X is nvl-unit) =
  self left: X | right: X;

command nvl-padding all: (X is nvl-unit) =
  self horizontal: X | vertical: X;


command #nvl-transform empty =
  new nvl-transform([]);

command #nvl-transform with: (Props is list<nvl-property>) =
  new nvl-transform(Props);


command #nvl-layer name: (Name is text) =
  new nvl-layer(name -> Name, transform -> #nvl-transform empty);

command nvl-layer transform: (Transform is nvl-transform) =
  new nvl-layer(self with transform -> Transform);


command #nvl-image from-asset: (Asset is package-asset) =
  new nvl-image(new nvl-source-asset(Asset));

command nvl-element transform: (T is nvl-transform) =
  new nvl-transform-element(self, T);