% crochet

type ljt-encoder(
  encoder is cell<binary-encoder>
);

command ljt-vm encode: (Value is ljt-value) do
  let Encoder = new ljt-encoder(#cell with-value: #binary-encoder empty);

  (Encoder encode: Value).encoder value as byte-array;
end

command ljt-vm try-encode: (Value is ljt-value) do
  trap errors-in: { self encode: Value };
end


command ljt-encoder encode: (X is v-bool) do
  self.encoder <- self.encoder value append-boolean: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-bool(true))
    =:= (#byte-array from: [0x01]);

  assert (#ljt-vm make encode: new v-bool(false))
    =:= (#byte-array from: [0x00]);
end

command ljt-encoder encode: (X is v-int8) do
  self.encoder <- self.encoder value append-integer-8bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-int8(-1))
    =:= (#byte-array from: [0xff]);

  assert (#ljt-vm make encode: new v-int8(0))
    =:= (#byte-array from: [0x00]);

  assert (#ljt-vm make-encode: new v-int8(1))
    =:= (#byte-array from: [0x01]);
end

command ljt-encoder encode: (X is v-int16) do
  self.encoder <- self.encoder value append-integer-16bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-int16(-1))
    =:= (#byte-array from: [0xff, 0xff]);

  assert (#ljt-vm make encode: new v-int16(0))
    =:= (#byte-array from: [0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-int16(1))
    =:= (#byte-array from: [0x01, 0x00]);

  assert (#ljt-vm make-encode: new v-int16(300))
    =:= (#byte-array from: [0x2c, 0x01]);
end

command ljt-encoder encode: (X is v-int32) do
  self.encoder <- self.encoder value append-integer-32bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-int32(-1))
    =:= (#byte-array from: [0xff, 0xff, 0xff, 0xff]);

  assert (#ljt-vm make encode: new v-int32(0))
    =:= (#byte-array from: [0x00, 0x00, 0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-int32(1))
    =:= (#byte-array from: [0x01, 0x00, 0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-int32(300))
    =:= (#byte-array from: [0x2c, 0x01, 0x00, 0x00]);  
end

command ljt-encoder encode: (X is v-uint8) do
  self.encoder <- self.encoder value append-unsigned-integer-8bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-uint8(0))
    =:= (#byte-array from: [0x00]);

  assert (#ljt-vm make-encode: new v-uint8(1))
    =:= (#byte-array from: [0x01]);

  assert (#ljt-vm make-encode: new v-uint8(255))
    =:= (#byte-array from: [0xff]);
end

command ljt-encoder encode: (X is v-uint16) do
  self.encoder <- self.encoder value append-unsigned-integer-16bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-uint16(0))
    =:= (#byte-array from: [0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-uint16(1))
    =:= (#byte-array from: [0x01, 0x00]);

  assert (#ljt-vm make-encode: new v-uint16(65_535))
    =:= (#byte-array from: [0xff, 0xff]);
end

command ljt-encoder encode: (X is v-uint32) do
  self.encoder <- self.encoder value append-unsigned-integer-32bit: X.value;
  self;
test
  assert (#ljt-vm make encode: new v-uint32(0))
    =:= (#byte-array from: [0x00, 0x00, 0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-uint32(1))
    =:= (#byte-array from: [0x01, 0x00, 0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-uint32(300))
    =:= (#byte-array from: [0x2c, 0x01, 0x00, 0x00]);

  assert (#ljt-vm make-encode: new v-uint32((2 ** 32) - 1))
    =:= (#byte-array from: [0xff, 0xff, 0xff, 0xff]);
end

command ljt-encoder encode: (X is v-float32) do
  self.encoder <- self.encoder value append-float-32bit: X.value;
  self;
end

command ljt-encoder encode: (X is v-float64) do
  self.encoder <- self.encoder value append-float-64bit: X.value;
  self;
end

command ljt-encoder encode: (X is v-integer) do
  self.encoder <- self.encoder value append: X.value;
  self;
end

command ljt-encoder encode: (X is v-text) do
  self.encoder <- self.encoder value append: X.value;
  self;
end

command ljt-encoder encode: (X is v-array) do
  self encode: new v-uint32(X.values count);
  for Value in X.values do
    self encode: Value;
  end
  self;
end

command ljt-encoder encode: (X is v-map) do
  self encode: new v-uint32(X.value count);
  for Pair in X.value entries do
    self encode: Pair key;
    self encode: Pair value;
  end
  self;
end

command ljt-encoder encode: (X is v-tuple) do
  for Value in X.values do
    self encode: Value;
  end
  self;
end

command ljt-encoder encode: (X is v-tagged) do
  self encode: new v-uint32(X.tag);
  self encode: X.value;
end

command ljt-encoder encode: (X is v-choice) do
  self encode: new v-uint32(X.value.tag);
  self encode: X.value.value;
end

command ljt-encoder encode: (X is v-just) do
  self encode: new v-bool(true);
  self encode: X.value;
end

command ljt-encoder encode: (X is v-none) do
  self encode: new v-bool(false);
end