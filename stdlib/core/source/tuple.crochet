% crochet

command (X is tuple) count =
  foreign tuple.count(X)
test
  assert [] count =:= 0;
  assert [1] count =:= 1;
  assert [1, 2, 3] count =:= 3;
end


command (X is tuple) at: (Index is integer)
requires within-bounds :: (Index >= 1) and (Index <= X count)
  = foreign tuple.at(X, Index)
test
  assert (["a", "b", "c"] at: 1) =:= "a";
  assert (["a", "b", "c"] at: 2) =:= "b";
  assert (["a", "b", "c"] at: 3) =:= "c";
end

command (X is tuple) at: (Index is integer) put: Value
requires within-bounds :: (Index >= 1) and (Index <= X count)
  = foreign tuple.at-put(X, Index, Value)
test
  assert (["a", "b", "c"] at: 1 put: "d") =:= ["d", "b", "c"];
  assert (["a", "b", "c"] at: 2 put: "d") =:= ["a", "d", "c"];
  assert (["a", "b", "c"] at: 3 put: "d") =:= ["a", "b", "d"];
end

command (X is tuple) delete-at: (Index is integer)
requires within-bounds :: (Index >= 1) and (Index <= X count)
  = foreign tuple.at-delete(X, Index)
test
  assert (["a"] delete-at: 1) =:= [];
  assert (["a", "b", "c"] delete-at: 2) =:= ["a", "c"];
  assert (["a", "b", "c"] delete-at: 3) =:= ["a", "b"];
end

command tuple first = self at: 1
test
  assert [1] first =:= 1;
  assert [1, 2, 3] first =:= 1;
end

command tuple second = self at: 2
test
  assert [1, 2] second =:= 2;
  assert [1, 2, 3] second =:= 2;
end

command tuple last = self at: self count
test
  assert [1] last =:= 1;
  assert [1, 2, 3] last =:= 3;
end


command (X is tuple) fold-from: Initial with: (Fun is function-2) =
  foreign tuple.fold(X, Initial, Fun)
test
  assert ([1, 2, 3] fold-from: 0 with: (_ + _)) =:= (1 + 2 + 3 + 0);
  assert ([] fold-from: 0 with: (_ + _)) =:= 0;
  assert ([1] fold-from: 0 with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-from: 6 with: (_ - _)) =:= (((6 - 1) - 2) - 3);
end

command (X is tuple) fold-right-from: Initial with: (Fun is function-2) =
  foreign tuple.foldr(X, Initial, Fun)
test
  assert ([] fold-right-from: 0 with: (_ + _)) =:= 0;
  assert ([1] fold-right-from: 0 with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-right-from: 6 with: (_ - _)) =:= (1 - (2 - (3 - 6)));
end


command (X is tuple) slice-from: (Start is integer) to: (End is integer)
requires
  positive :: Start >= 1;
  progressive :: Start <= End;
  = foreign tuple.slice(X, Start, End)
test
  assert ([] slice-from: 1 to: 4) =:= [];
  assert ([0, 1, 2, 3] slice-from: 1 to: 4) =:= [0, 1, 2, 3];
  assert ([0, 1, 2, 3] slice-from: 1 to: 1) =:= [0];
  assert ([0, 1, 2, 3] slice-from: 4 to: 4) =:= [3];
  assert ([0, 1, 2, 3] slice-from: 2 to: 3) =:= [1, 2];
  assert ([0, 1, 2, 3] slice-from: 3 to: 5) =:= [2, 3];
end

command tuple take: (N is integer)
requires positive-size :: N >= 0
do
  condition
    when N === 0 => [];
    when self is-empty => [];
    always => self slice-from: 1 to: N;
  end
test
  assert ([] take: 0) =:= [];
  assert ([1, 2, 3] take: 0) =:= [];
  assert ([1, 2, 3] take: 2) =:= [1, 2];
end

command tuple drop: (N is integer)
requires positive-size :: N >= 0
do
  condition
    when N === 0 => self;
    when self is-empty => [];
    always => self slice-from: (N + 1) to: self count;
  end
test
  assert ([] drop: 0) =:= [];
  assert ([1, 2, 3] drop: 0) =:= [1, 2, 3];
  assert ([1, 2, 3] drop: 2) =:= [3];
end

command tuple but-first =
  condition
    when self count < 2 => [];
    always => self slice-from: 2 to: self count;
  end
test
  assert [] but-first =:= [];
  assert [1] but-first =:= [];
  assert [1, 2, 3] but-first =:= [2, 3];
end

command tuple but-last =
  condition
    when self count < 2 => [];
    always => self slice-from: 1 to: (self count - 1);
  end
test
  assert [] but-last =:= [];
  assert [1] but-last =:= [];
  assert [1, 2, 3] but-last =:= [1, 2];
end

command tuple filter: (Fun is function-1) do
  for X in self if Fun(X) do X end;
end

command (X is tuple) zip: (That is tuple) with: (Fun is function-2)
requires same-size :: self count === That count
  = foreign tuple.zip-with(X, That, Fun);

command tuple all-true =
  self fold-from: true with: (_ and _);