% crochet

command (X is tuple) reverse
ensures same-size :: self count === return count
  = foreign tuple.reverse(X)
test
  assert [] reverse =:= [];
  assert [1] reverse =:= [1];
  assert [1, 2, 3] reverse =:= [3, 2, 1];
end

local type sorter;
command #sorter sort: (X is tuple) by: (Comparator is function-2)
  = foreign tuple.sort(X, Comparator);

command #sorter compare: A and: B with: F do
  let Result = F(A, B);
  condition
    when Result === less-than => -1;
    when Result === equal => 0;
    when Result === greater-than => 1;
  end
end

// FIXME: currently limited to pure synchronous functions
command (X is tuple) sort-by: (Comparator is function-2)
ensures same-size :: self count === return count do
  #sorter sort: X by: (#sorter compare: _ and: _ with: Comparator);
test
  assert ([] sort-by: (_ compare-to: _)) =:= [];
  assert ([1] sort-by: (_ compare-to: _)) =:= [1];
  assert ([-2, 1, 0, 3] sort-by: (_ compare-to: _)) =:= [-2, 0, 1, 3];
end

command (X is tuple) sort
ensures same-size :: self count === return count
  = self sort-by: (_ compare-to: _)
test
  assert ([] sort) =:= [];
  assert ([1] sort) =:= [1];
  assert ([-2, 1, 0, 3] sort) =:= [-2, 0, 1, 3];
end