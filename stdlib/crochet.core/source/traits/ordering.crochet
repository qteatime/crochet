% crochet

enum ordering = less-than, equal, greater-than;

// Ordering
//
// - Required: `_ < _` and `_ > _` with equality
// - Get: `_ <= _`, `_ >= _`, `greater-of:and:`, `lesser-of:and:` for free.
//
// We could derive `<` from `>` and vice-versa, but Crochet doesn't offer
// good features for checking this yet, and that causes recursion issues...

/// Default less or equal to
command X <= Y =
  (X === Y) or (X < Y)
test
  assert 1 <= 1;
  assert 1 <= 2;
end

/// Default greater or equal to
command X >= Y =
  (X === Y) or (X > Y)
test
  assert 1 >= 1;
  assert 2 >= 1;
end

command greater-of: X and: Y =
  condition
    when X >= Y => X;
    always => Y;
  end
test
  assert (greater-of: 1 and: 2) =:= 2;
  assert (greater-of: 5 and: 2) =:= 5;
  assert (greater-of: 0 and: 0) =:= 0;
  assert (greater-of: 1 and: -1) =:= 1;
end

command lesser-of: X and: Y =
  condition
    when X <= Y => X;
    always => Y;
  end
test
  assert (lesser-of: 1 and: 2) =:= 1;
  assert (lesser-of: 5 and: 2) =:= 2;
  assert (lesser-of: 0 and: 0) =:= 0;
  assert (lesser-of: 1 and: -1) =:= -1;
end


// # Generic comparison
command X compare-to: Y do
  condition
    when X === Y => equal;
    when X < Y   => less-than;
    when X > Y   => greater-than;
  end
test
  assert (1 compare-to: 1) =:= equal;
  assert (-1 compare-to: 0) =:= less-than;
  assert (1 compare-to: 0) =:= greater-than;
end


// # Enums
local enum test-enum = ta, tb, tc;

/// Less than relationship
command 'enum < (Other is 'enum) =
  self to-enum-integer < Other to-enum-integer
test
  assert ta < tb;
  assert tb < tc;
  assert not (tc < ta);
end

/// Greater than relationship
command 'enum > (Other is 'enum) =
  self to-enum-integer > Other to-enum-integer
test
  assert tb > ta;
  assert tc > tb;
  assert not (ta > tc);
end


// # Numbers

/// Returns [X] restricted to the range between [Min] and [Max].
/// That is, if [X] is outside of the range, will return [Min]
/// or [Max].
command (X has ordered) clamp-between: (Min has ordered) and: (Max has ordered) do
  condition
    when X < Min => Min;
    when X > Max => Max;
    always => X;
  end
test
  assert (-1 clamp-between: 0 and: 2) ==> 0;
  assert (0 clamp-between: 0 and: 2) ==> 0;
  assert (1 clamp-between: 0 and: 2) ==> 1;
  assert (2 clamp-between: 0 and: 2) ==> 2;
  assert (3 clamp-between: 0 and: 2) ==> 2;
end
