% crochet

/// A sequence that contains elements from the first one up until the `Predicate`
/// stops holding.
command (X has sequence, appendable-sequence, countable-container) take-while: (Predicate is (A -> boolean)) do
  let Go = { Xs in
    condition
      when Xs is-empty => Xs;
      when Predicate(Xs first) => Go(Xs rest) prepend: Xs first;
      otherwise => Xs empty;
    end
  };
  Go(X);
test
  assert ([] take-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] take-while: (_ <= 2)) === [1, 2];
  assert ([1, 2, 3, 2, 1] take-while: (_ <= 2)) === [1, 2];
end

/// A sequence that contains elements from when the [Predicate] starts holding
/// up to the last element.
command (X has sequence, countable-container) drop-while: (Predicate is (A -> boolean)) do
  let Go = { Xs in
    condition
      when Xs is-empty => Xs;
      when Predicate(Xs first) => Go(Xs rest);
      otherwise => Xs;
    end
  };
  Go(X);
test
  assert ([] drop-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] drop-while: (_ <= 2)) === [3, 4];
  assert ([1, 2, 3, 2, 1] drop-while: (_ <= 2)) === [3, 2, 1];
end


/// Returns the first item, wrapped in [type:result], in the sequence for which
/// the predicate holds, or [type:not-found] if no items pass the predicate.
///
/// This function looks at as many items in the sequence as necessary to find
/// the first item, but no more than that. However, it can potentially span
/// the entire sequence, thus why it's limited to finite ones.
command (Xs has finite-sequence) find-first: (Predicate is (A -> boolean)) -> result<A, not-found> do
  let Go = { Xs in
    condition
      when Xs is-empty => #result error: not-found;
      when Predicate(Xs first) => perform non-local.result(Xs first);
      otherwise => Go(Xs rest);
    end
  };

  handle
    Go(Xs);
  with
    on non-local.result(X) => #result ok: X;
  end
test
  assert ([1, 2, 3] find-first: (_ > 1)) === (#result ok: 2);
  assert ([1, 2, 3] find-first: (_ > 3)) === (#result error: not-found);
end


command (X has indexed-sequence) second =
  X at: 2;

command (X has indexed-sequence) third =
  X at: 3;

command (X has indexed-sequence) fourth =
  X at: 4;

command (X has indexed-sequence) fifth =
  X at: 5;

command (X has indexed-sequence) sixth =
  X at: 6;

command (X has indexed-sequence) seventh =
  X at: 7;

command (X has indexed-sequence) eight =
  X at: 8;

command (X has indexed-sequence) ninth =
  X at: 9;