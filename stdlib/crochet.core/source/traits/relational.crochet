% crochet

local type eq-test-instance;

// # Universal relations

/// Universal equality
command X === Y =
  foreign core.eq(X, Y)
test
  // Equality is still segregated by types (but this can be overriden)
  assert 1 === 1;
  assert not (1 === "1");

  // Equality does not violate sealing
  assert not (1 === (1 as unknown));

  // Equality does not automatically coerce booleans
  assert not (false === []);

  // Equality is structural on structural types
  assert [1, 2, 3] === [1, 2, 3];
  assert [a -> 1] === [a -> 1];
  assert not ([1, 2, 3] === [1, 2, 4]);
  assert not ([a -> 1] === [a -> 2]);

  // Equality for records is strict
  assert not ([a -> 1] === [a -> 1, b -> 2]);

  // User-defined types are not structural by default
  // (this is extremely important for capabilities)
  let A = new eq-test-instance;
  let B = new eq-test-instance;
  assert A === A;
  assert B === B;
  assert not (A === B);

  // FIXME: Incidentally, partials are not structural either
  let F1 = _ === _;
  let F2 = _ === _;
  assert F1 === F1;
  assert F2 === F2;
  assert not (F1 === F2);
end

/// Universal non-equality
command X =/= Y =
  not (X === Y)
test
  assert 1 =/= 2;
end

// FIXME: Defined so enums and etc get them for free, but it looks weird here.
//        This will be fixed once Crochet gets some kind of trait definition.

/// Universal less or equal to
command X <= Y =
  (X === Y) or (X < Y)
test
  assert 1 <= 1;
  assert 1 <= 2;
end

/// Universal greater or equal to
command X >= Y =
  (X === Y) or (X > Y)
test
  assert 1 >= 1;
  assert 2 >= 1;
end

// # Numeric relations

/// Relational less than operator for integers
command (X is integer) < (Y is integer) = 
  foreign integer.lt(X, Y)
test
  assert 0 < 1;
  assert -1 < 0;
  assert not (0 < 0);
  assert not (1 < 0);
end

/// Relational less than or equal operator for integers (provided for perf)
command (X is integer) <= (Y is integer) = 
  foreign integer.lte(X, Y)
test
  assert 0 <= 1;
  assert -1 <= 0;
  assert 0 <= 0;
  assert not (1 <= 0);
end

/// Relational greater than operator for integers
command (X is integer) > (Y is integer) = 
  foreign integer.gt(X, Y)
test
  assert 1 > 0;
  assert 0 > -1;
  assert not (0 > 0);
  assert not (0 > 1);
end

/// Relational greater or equal operator for integers (provided for perf)
command (X is integer) >= (Y is integer) = 
  foreign integer.gte(X, Y)
test
  assert 1 >= 0;
  assert 0 >= -1;
  assert 0 >= 0;
  assert not (0 >= 1);
end


/// Relational less than operator for floats
command (X is float) < (Y is float) = 
  foreign float.lt(X, Y)
test
  assert 0.0 < 1.0;
  assert -1.0 < 0.0;
  assert not (0.0 < 0.0);
  assert not (1.0 < 0.0);
end

/// Relational less than or equal operator for floats (provided for perf)
command (X is float) <= (Y is float) = 
  foreign float.lte(X, Y)
test
  assert 0.0 <= 1.0;
  assert -1.0 <= 0.0;
  assert 0.0 <= 0.0;
  assert not (1.0 <= 0.0);
end

/// Relational greater than operator for floats
command (X is float) > (Y is float) = 
  foreign float.gt(X, Y)
test
  assert 1.0 > 0.0;
  assert 0.0 > -1.0;
  assert not (0.0 > 0.0);
  assert not (0.0 > 1.0);
end

/// Relational greater or equal operator for floats (provided for perf)
command (X is float) >= (Y is float) = 
  foreign float.gte(X, Y)
test
  assert 1.0 >= 0.0;
  assert 0.0 >= -1.0;
  assert 0.0 >= 0.0;
  assert not (0.0 >= 1.0);
end


// # Relational operators across numeric types
command (X is integer) <  (Y is float) = (#float coerce: X) < Y;
command (X is integer) <= (Y is float) = (#float coerce: X) <= Y;
command (X is integer) >  (Y is float) = (#float coerce: X) > Y;
command (X is integer) >= (Y is float) = (#float coerce: X) >= Y;

command (X is float) <  (Y is integer) = X <  (#float coerce: Y);
command (X is float) <= (Y is integer) = X <= (#float coerce: Y);
command (X is float) >  (Y is integer) = X >  (#float coerce: Y);
command (X is float) >= (Y is integer) = X >= (#float coerce: Y);

command (X is integer) === (Y is float) = (#float coerce: X) === Y;
command (X is integer) =/= (Y is float) = (#float coerce: X) =/= Y;
command (X is float) === (Y is integer) = X === (#float coerce: Y);
command (X is float) =/= (Y is integer) = X =/= (#float coerce: Y);

test "Relational conversions" do
  assert (0 < 1.1);
  assert (0 <= 0.0);
  assert (1 > 0.0);
  assert (1 >= 0.9);

  assert (0.9 < 1);
  assert (0.0 <= 0);
  assert (1.1 > 0);
  assert (0.0 >= 0);

  assert (1.0 === 1);
  assert (1.1 =/= 1);
  assert (1 === 1.0);
  assert (1 =/= 1.1);
end

// # Enums
local enum test-enum = ta, tb, tc;

/// Less than relationship
command 'enum < (Other is 'enum) =
  self to-enum-integer < Other to-enum-integer
test
  assert ta < tb;
  assert tb < tc;
  assert not (tc < ta);
end

/// Greater than relationship
command 'enum > (Other is 'enum) =
  self to-enum-integer > Other to-enum-integer
test
  assert tb > ta;
  assert tc > tb;
  assert not (ta > tc);
end


// # Text and interpolation
local type relational-interpolation;
command #relational-interpolation equal: X and: Y =
  foreign interpolation.equals(X, Y);

command (X is interpolation) === (Y is interpolation) do
  #relational-interpolation equal: X and: Y
test
  assert "a["b"]c" === ("abc" as interpolation);
end

command (X is interpolation) === (Y is text) do
  X === (Y as interpolation)
test
  assert "a["b"]c" === "abc";
end

command (X is text) === (Y is interpolation) do
  (X as interpolation) === Y
test
  assert "a["b"]c" === "abc";
end