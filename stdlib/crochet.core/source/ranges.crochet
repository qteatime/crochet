% crochet

// # Enums

local enum test-enum = ta, tb, tc;

/// Range of enums (inclusive on both ends)
command (From0 is 'enum) to: (To0 is 'enum)
requires ordered = From0 <= To0
do
  // FIXME: ideally we wouldn't depend on integers here
  let From = From0 to-enum-integer;
  let To = To0 to-enum-integer;
  for I in From to: To do From0 from-enum-integer: I end
test
  assert (ta to: tc) === [ta, tb, tc];
  assert (tb to: tc) === [tb, tc];
  assert (tc to: tc) === [tc];
end

/// Range of enums, only inclusive on the starting end
command (From0 is 'enum) until: (To0 is 'enum)
requires ordered = From0 <= To0
do
  // FIXME: ideally we wouldn't depend on integers here
  let From = From0 to-enum-integer;
  let To = To0 to-enum-integer;
  for I in From until: To do From0 from-enum-integer: I end
test
  assert (ta to: tc) === [ta, tb, tc];
  assert (tb to: tc) === [tb, tc];
  assert (tc to: tc) === [tc];
end


// # Integers

/// The range of integers from Min to: Max, inclusive on both bounds.
command (Min is integer) to: (Max is integer)
requires ordered = Min <= Max
  = foreign integer.range(Min, Max)
test
  assert (1 to: 3) === [1, 2, 3];
  assert (2 to: 3) === [2, 3];
  assert (3 to: 3) === [3];
end

/// The range of integers from Min until: Max, not inclusive on Max.
command (Min is integer) until: (Max is integer)
requires ordered = Min <= Max
do
  condition
    when Min === Max => [];
    always => Min to: (Max - 1);
  end
test
  assert (1 until: 3) === [1, 2];
  assert (2 until: 3) === [2];
  assert (3 until: 3) === [];
end