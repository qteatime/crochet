% crochet

// -- The hierarchy

/// The base of the type hierarchy in Crochet.
///
/// The `any` type matches any value, but provides no information about them.
/// It effectively opts out of the type system in some region of the code.
type any = foreign core.any;

/// A sealed type for any value in Crochet.
///
/// Values can be wrapped in `unknown` to pass them around without granting
/// any capabilities. This gives Crochet a stronger gradual-typing guarantee,
/// but at the cost of being practical. Values must be explicitly sealed and
/// unsealed.
type unknown = foreign core.unknown;

/// The unit type which represents the absense of useful values.
type nothing = foreign core.nothing;


// -- The logic

/// The base type for two-valued logical values.
///
/// Booleans model a two-valued logic with two possible values:
/// [true] and [false].
type boolean = foreign core.boolean;

/// The true case of booleans.
type true = foreign core.true;

/// The false case of booleans.
type false = foreign core.false;


// -- The numeric tower

/// The base type for the numeric tower.
///
/// Any numeric types in Crochet are expected to be a subtype of [numeric].
type numeric = foreign core.numeric;

/// The base type for fractional numbers.
///
/// Any representations of fractions or real numbers with a fractional part
/// should be a subtype of [fractional].
type fractional = foreign core.fractional;

/// The type for IEEE-754 64-bit floating point numbers.
type float = foreign core.float;

/// The base type for integral numbers.
///
/// Any representation of whole integral numbers should be a subtype of
/// [integral].
type integral = foreign core.integral;

/// The type of arbitrary-precision integers.
type integer = foreign core.integer;


// -- The textual representation

/// The type of textual values.
///
/// All textual types descend from [text]. And a [text] is always to be
/// considered an opaque blob, only operated on through whatever text
/// commands are available, and with representation that's entirely up
/// to the runtime---indeed, the representation may change if the runtime
/// thinks that's more efficient.
type text = foreign core.text;

/// The type of text *literals* in source programs.
///
/// This type assures users that the piece of text originates from the
/// program itself. In this sense, [static-text] represents a piece of
/// text that is trusted to not come from external sources.
type static-text = foreign core.static-text;

/// The type of interpolation sequences.
///
/// An interpolation is not a descendant of [text], but rather its own
/// first class concept of mixed values. Interpolations reify the idea
/// of text that may contain other pieces of data within it, and turn
/// this into a kind of tree-based representation of values. This
/// makes sure we don't violate implicit rules in pieces of text
/// by simply composing them with other things, just like typed
/// data does for combining distinct data points.
type interpolation = foreign core.interpolation;


// -- The functions

/// The type of any applicable function.
type function = foreign core.function;

/// Functions that take no arguments.
type function-0 = foreign core.function-0;

/// Functions that take one argument.
type function-1 = foreign core.function-1;

/// Functions that take two arguments.
type function-2 = foreign core.function-2;

/// Functions that take three arguments.
type function-3 = foreign core.function-3;

/// Functions that take four arguments.
type function-4 = foreign core.function-4;

/// Functions that take five arguments.
type function-5 = foreign core.function-5;

/// Functions that take six arguments.
type function-6 = foreign core.function-6;

/// Functions that take seven arguments.
type function-7 = foreign core.function-7;

/// Functions that take eight arguments.
type function-8 = foreign core.function-8;

/// Functions that take nine arguments.
type function-9 = foreign core.function-9;


/// The type of lazy expressions.
///
/// A [thunk] is similar to a [function-0], in that it represents
/// a computation that hasn't been evaluated yet (therefore we don't know
/// what it's value will be). However, [thunk]s also provide a guarantee
/// that the computation will be evaluated at most once, no matter how 
/// many times we try to get the value out of it.
type thunk = foreign core.thunk;


// -- The collections

/// The type of records.
///
/// A record is a collection of named data points, like typed data, but
/// without the "type" part of it. In that sense, it can bring together
/// independent values and identify them in many contexts where security,
/// privacy, and command specialisation are not a concern.
///
/// Records are constructable by anyone, inspectable by anyone, and
/// extensible by anyone.
type record = foreign core.record;

/// The type of fixed-length sequences.
///
/// A list is an ordered sequence of values, possibly of different types.
/// This sequence is fixed---you cannot modify it to have more or less
/// values. And although there are certain list operations that allow
/// you to construct new ones that have more or less elements, this is
/// not optimised, and thus not expected to be a common occurrence.
///
/// This limitation of lists is also its strength: it allows the runtime
/// to choose more efficient ways of storing and using it.
type list = foreign core.list;

/// The type of linked lists.
///
/// A linked list is an ordered sequence of values of the same type
/// which can grow by having new values prepended to this sequence.
/// Prepending elements and iterating elements in order is cheap,
/// but linked lists are not great for use cases where elements
/// need to be accessed out of order, or where many insertions
/// happen at the end of the list.
///
/// Linked lists are an inductive structure with two cases:
/// it can be either the [empty-list], meaning there's nothing in it,
/// or a [cons-list], meaning there's one value that's followed by
/// possibly many others, as described by its `rest` field.
abstract linked-list;
/// The empty case of linked lists.
singleton empty-list is linked-list;
/// The at-least-one-value case of linked lists.
type cons-list(value, rest is linked-list);

/// The base type of enumerations.
///
/// An enumeration is a bounded collection of distinct and ordered values.
type 'enum = foreign core.enum;


// -- The skeleton DSL
type skeleton-ast = foreign core.skeleton-ast;
type skeleton-node = foreign core.skeleton-node;
type skeleton-name = foreign core.skeleton-name;
type skeleton-literal = foreign core.skeleton-literal;
type skeleton-list = foreign core.skeleton-list;
type skeleton-interpolation = foreign core.skeleton-interpolation;
type skeleton-dynamic = foreign core.skeleton-dynamic;


//-- The actions

/// The base type for all actions.
type 'action = foreign core.action;

/// The type of possible choices for actions (with bound environments) that
/// the simulation constructs on each turn.
type action-choice = foreign core.action-choice;


// -- The idea of computational failure

/// The type of results that may fail.
///
/// A result explicitly models the idea that a computation may fail, and then
/// reifies the status of the evaluation (whether it succeeded or failed),
/// along with the value it would otherwise produce.
abstract result;

/// Represents successful evaluations.
type ok(value) is result;

/// Represents failed evaluations.
type error(reason) is result;


// -- The idea of state

/// The type of mutable cells.
type cell = foreign core.cell;

/// A wrapper that allows accessing the value of a cell but not changing it.
type read-only-cell(cell);


// -- The idea of inspecting data

/// The module for representations
singleton representation;
singleton debug-representation;


//-- Other types Other types
type indexed(index is integer, value);


// -- Traits

/// A type has [equality] if it's possible to determine, for any pair of
/// values it can have, if they're equal or not.
///
/// We assume that equality is "structural". That is, there's an expectation
/// that `A === B` will hold even if `A` and `B` are not the exact same
/// typed data, as long as they can *mean* the same thing.
///
/// What "mean the same thing" should stand for is up to each type.
trait equality with
  /// True if two values (of the same type) mean the same thing.
  command A === B -> boolean;

  /// (optional) True if two values (of the same type) do not mean the same thing.
  command A =/= B -> boolean;
end


/// A type has a [total-ordering] if for any pair of values, the operation
/// `A <= B` makes sense. It builds upon [equality] because of that.
trait total-ordering with
  requires trait equality;

  /// True if `A` is considered lower than `B`.
  command A < B -> boolean;

  /// True if `A` is considered higher than `B`.
  command A > B -> boolean;

  /// (optional) True if `A` is less than or equal to `B`.
  command A <= B -> boolean;

  /// (optional) True if `A` is greater than or equal to `B`.
  command A >= B -> boolean;
end


/// A type has [bounds] if it has [total-ordering] and there are known
/// discrete limits that determine the range of values in the type.
/// Such limits are described by [_ lower-bound] and [_ upper-bound].
trait bounds with
  requires trait total-ordering;

  /// The minimum value in the type.
  command A lower-bound;

  /// The maximum value in the type.
  command A upper-bound;
end


/// A type has [enumeration] if its values are discretely ordered such that
/// it's possible to always get the immediate next smaller or greater value.
trait enumeration with
  requires trait total-ordering;

  /// The value that comes immediately after `A`.
  command A successor
    ensures greater :: return > A;

  /// The value that comes immediately before `A`.
  command A predecessor
    ensures lesser :: return < A;

  /// (optional) Inclusive arithmetic sequence `(Start, Stop)`
  command Start to: Stop by: Step
    requires ordered :: Start <= Stop,
             progress :: Step > 0;

  /// (optional) End-exclusive arithmetic sequence `(Start, Stop(`
  command Start until: Stop by: Step
    requires ordered :: Start <= Stop,
             progress :: Step > 0;
end


/// A type has a [boolean-algebra] if it can implement the common boolean
/// operations (respecting their laws).
///
/// A proper implementation of [boolean-algebra] requires:
///
/// * Associativity of `or`:                x or (y or z) =:= (x or y) or z
/// * Associativity of `and`:               x and (y and z) =:= (x and y) and z
/// * Commutativity of `or`:                x or y =:= y or x
/// * Commutativity of `and`:               x and y =:= y and x
/// * Distributivity of `or` over `and`:    x or (y and z) =:= (x and y) or (x and z)
/// * Idempotence of `or`:                  x or x =:= x
/// * Idempotence of `and`:                 x and x =:= x
/// * Absorption:                           x and (x or y) =:= x
///                                         x or (x and y) =:= x
/// * Double negation:                      not (not x) =:= x
trait boolean-algebra with
  /// Logical conjunction.
  command A and B;

  /// Logical disjunction.
  command A or B;

  /// Logical negation.
  command not A;
end


/// A type has an [arithmetic] if it can implement the common
/// arithmetic operations. This generally means you have
/// some kind of number.
///
/// Common arithmetic laws apply.
trait arithmetic with
  /// Arithmetic addition.
  command A + B;

  /// Arithmetic subtraction.
  command A - B;

  /// Arithmetic multiplication.
  command A * B;

  /// Truncating arithmetic division (the result is always an integer)
  command A divided-by: B
    requires non-zero-divisor :: B =/= 0;

  /// Fractional arithmetic division (the result might be a real number).
  command A / B
    requires non-zero-divisor :: B =/= 0;

  /// Remainder of an arithmetic division.
  command A % B
    requires non-zero-divisor :: B =/= 0;

  /// Exponentiation (exponents are expected to be integrals)
  command A ** B
    requires positive-exponent :: B >= 0;
end


/// A type generally has [rounding-strategies] if it's a
/// fractional type.
trait rounding-strategies with
  /// Gets rid of the fractional part.
  command A truncate;

  /// Returns the next smaller integer.
  command A floor;

  /// Returns the next larger integer.
  command A ceiling;

  /// Returns the nearest integer.
  command A round;
end