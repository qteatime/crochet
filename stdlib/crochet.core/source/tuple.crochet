% crochet

command (X is tuple) count =
  foreign tuple.count(X)
test
  assert [] count =:= 0;
  assert [1] count =:= 1;
  assert [1, 2, 3] count =:= 3;
end

command (X is tuple) is-empty =
  X count =:= 0
test
  assert [] is-empty;
  assert not ([0] is-empty);
end

command (X is tuple) at: (Index is integer)
requires within-bounds :: (Index >= 1) and (Index <= X count)
  = foreign tuple.at(X, Index)
test
  assert (["a", "b", "c"] at: 1) =:= "a";
  assert (["a", "b", "c"] at: 2) =:= "b";
  assert (["a", "b", "c"] at: 3) =:= "c";
end

command tuple first = self at: 1
test
  assert [1] first =:= 1;
  assert [1, 2, 3] first =:= 1;
end

command tuple last = self at: self count
test
  assert [1] last =:= 1;
  assert [1, 2, 3] last =:= 3;
end

/// Inclusive on both bounds
command (X is tuple) slice-from: (Start is integer) to: (End is integer)
requires
  positive :: Start >= 1;
  progressive :: Start <= End;
  = foreign tuple.slice(X, Start, End)
test
  assert ([] slice-from: 1 to: 4) =:= [];
  assert ([0, 1, 2, 3] slice-from: 1 to: 4) =:= [0, 1, 2, 3];
  assert ([0, 1, 2, 3] slice-from: 1 to: 1) =:= [0];
  assert ([0, 1, 2, 3] slice-from: 4 to: 4) =:= [3];
  assert ([0, 1, 2, 3] slice-from: 2 to: 3) =:= [1, 2];
  assert ([0, 1, 2, 3] slice-from: 3 to: 5) =:= [2, 3];
end


command tuple but-first =
  condition
    when self count < 2 => [];
    always => self slice-from: 2 to: self count;
  end
test
  assert [] but-first =:= [];
  assert [1] but-first =:= [];
  assert [1, 2, 3] but-first =:= [2, 3];
end

command tuple but-last =
  condition
    when self count < 2 => [];
    always => self slice-from: 1 to: (self count - 1);
  end
test
  assert [] but-last =:= [];
  assert [1] but-last =:= [];
  assert [1, 2, 3] but-last =:= [1, 2];
end

command tuple take: (N is integer)
requires positive-size :: N >= 0
do
  condition
    when N === 0 => [];
    when self is-empty => [];
    always => self slice-from: 1 to: N;
  end
test
  assert ([] take: 0) =:= [];
  assert ([1, 2, 3] take: 0) =:= [];
  assert ([1, 2, 3] take: 2) =:= [1, 2];
end

command tuple drop: (N is integer)
requires positive-size :: N >= 0
do
  condition
    when N === 0 => self;
    when self is-empty => [];
    always => self slice-from: (N + 1) to: self count;
  end
test
  assert ([] drop: 0) =:= [];
  assert ([1, 2, 3] drop: 0) =:= [1, 2, 3];
  assert ([1, 2, 3] drop: 2) =:= [3];
end

command (X is tuple) ++ (Y is tuple) = 
  foreign tuple.concat(X, Y)
test
  assert ([] ++ []) =:= [];
  assert ([1, 2, 3] ++ []) =:= [1, 2, 3];
  assert ([] ++ [1, 2, 3]) =:= [1, 2, 3];
  assert ([1, 2] ++ [3, 4, 5]) =:= [1, 2, 3, 4, 5];
end
