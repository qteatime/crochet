% crochet

/// Represents nothing
command #document empty =
  doc-empty;

/// Represents any number
command #document number: (X is numeric) =
  new doc-number(X)
    | typed: (foreign debug.type(X));

/// Represents any crochet text (and _highlights_ that it is a Crochet text,
/// e.g.: by having quotes around it).
command #document crochet-text: (X is unsafe-arbitrary-text) =
  new doc-text(X);

/// Represents any boolean.
command #document boolean: (X is boolean) =
  new doc-boolean(X);


/// Represents a piece of text with no semantics.
command #document plain-text: (X is text) =
  new doc-plain-text(X);

command #document plain-text: (X is interpolation) =
  #document plain-text: (X flatten-into-plain-text);

/// Represents a piece of text with monospaced font.
command #document code: (X is text) =
  new doc-code(X);

command #document code: (X is interpolation) =
  #document plain-text: (X flatten-into-plain-text);

/// Represents a list of values.
command #document list: (Xs is list<document>) =
  new doc-list(Xs);

/// Represents a table of values.
command #document table-header: (Hs is list<document>) rows: (Rs is list<doc-table-row>)
requires
  consistent-layout :: Rs all: { R in R.cells count === Hs count }
do
  new doc-table(Hs, Rs);
end

/// Represents a row in a table.
command #document table-row: (Cells is list<document>) =
  new doc-table-row(Cells);

/// Lays items with flow layouting.
command #document flow: (Xs is list<document>) =
  new doc-flow(Xs);

/// Lays items with a flex row.
command #document flex-row: (Xs is list<document>) =
  new doc-flex-row(Xs, doc-unit-unset);

/// Lays items with a flex column.
command #document flex-column: (Xs is list<document>) =
  new doc-flex-column(Xs, doc-unit-unset);

/// Lays items with a fixed layout.
command #document fixed-layout: (Xs is list<document>) width: (W is doc-unit) height: (H is doc-unit) =
  new doc-fixed-layout(Xs, W, H);

/// Constructs a table from a record of fields.
command #document fields: (R is record) do
  let Rows = R pairs
               | map: { P in #document table-row: [#document plain-text: P key, P value] };
  #document
    | table-header: [#document plain-text: "Field", #document plain-text: "Value"]
      rows: Rows
    | compact-layout: (
        #document plain-text: "([Rows count to-text] fields)"
      );
end

/// Constructs a circle shape
command #document circle-x: (X is doc-unit) y: (Y is doc-unit) radius: (Radius is doc-unit) style: (Style is doc-presentation) =
  new doc-circle(X, Y, Radius, Style);

/// Represents a typed value.
command document typed: (Type is static-type) =
  new doc-typed(self, Type);

/// Positions a document in a fixed layout.
command document x: (X is doc-unit) y: (Y is doc-unit) =
  self position: new doc-point2d(X, Y)
       anchor: new doc-point2d(doc-unit-unset, doc-unit-unset);

/// Positions a document in a fixed layout.
command document position: (Pos is doc-point2d) anchor: (Anchor is doc-point2d) =
  new doc-position(self, Pos, Anchor);

/// Provides a compact layout alternative.
command document compact-layout: (Doc is document) =
  new doc-group(Doc, self);

/// Provides an expanded layout alternative.
command document expanded-layout: (Doc is document) =
  new doc-group(self, Doc);


// -- Styles
command #document style =
  new doc-presentation(doc-colour-transparent, doc-unit-unset, doc-colour-transparent);

command doc-presentation stroke-colour: (Colour is doc-colour) =
  new doc-presentation(Colour, self.stroke-width, self.fill-colour);

command doc-presentation stroke-width: (Width is doc-unit) =
  new doc-presentation(self.stroke-colour, Width, self.fill-colour);

command doc-presentation fill-colour: (Colour is doc-colour) =
  new doc-presentation(self.stroke-colour, self.stroke-width, Colour);


command #doc-unit unset = doc-unit-unset;

command integer as doc-pixels =
  new doc-pixels(self);

command float as doc-percent =
  new doc-percent(self);

command float as doc-em =
  new doc-em(self);


command #doc-point2d x: (X is doc-unit) y: (Y is doc-unit) =
  new doc-point2d(X, Y);

command #doc-colour transparent =
  doc-colour-transparent;

command #doc-colour red: (R is integer) green: (G is integer) blue: (B is integer) alpha: (A is integer)
requires
  byte-red :: (R >= 0) and (R <= 255),
  byte-green :: (G >= 0) and (G <= 255),
  byte-blue :: (B >= 0) and (B <= 255),
  byte-alpha :: (A >= 0) and (A <= 255)
do
  new doc-colour-rgba(R, G, B, A);
end