% crochet

// -- Constructors
command #list empty = [];

command list second = self at: 2;
command list third = self at: 3;












command list take-while: (Fun is function-1) do
  let Go = { Xs in
    condition
      when Xs is-empty => [];
      when Fun(Xs first) => [Xs first] ++ Go(Xs rest);
      always => [];
    end
  };
  Go(self);
test
  assert ([] take-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] take-while: (_ <= 2)) === [1, 2];
  assert ([1, 2, 3, 2, 1] take-while: (_ <= 2)) === [1, 2];
end


command list drop-while: (Fun is function-1) do
  let Go = { Xs in
    condition
      when Xs is-empty => [];
      when Fun(Xs first) => Go(Xs rest);
      always => Xs;
    end
  };
  Go(self);
test
  assert ([] drop-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] drop-while: (_ <= 2)) === [3, 4];
  assert ([1, 2, 3, 2, 1] drop-while: (_ <= 2)) === [3, 2, 1];
end


command list enumerate =
  condition
    when self is-empty => [];
    always => (1 to: self count) zip: self with: { I, V in new indexed(I, V) };
  end
test
  assert ([] enumerate) === [];
  assert (["a", "b", "c"] enumerate)
    === [new indexed(1, "a"), new indexed(2, "b"), new indexed(3, "c")];
end


// -- Collection transformations
command list keep-if: (Fun is function-1) do
  for X in self if Fun(X) do X end
test
  assert ([] keep-if: (_ > 2)) === [];
  assert ([1, 2, 3, 2, 1] keep-if: (_ > 2)) === [3];
  assert ([1, 5, 3, 1, 6, 2] keep-if: (_ > 2)) === [5, 3, 6];
end


command list remove-if: (Fun is function-1) do
  for X in self if not Fun(X) do X end;
test
  assert ([] remove-if: (_ > 2)) === [];
  assert ([1, 2, 3, 2, 1] remove-if: (_ > 2)) === [1, 2, 2, 1];
  assert ([1, 5, 3, 1, 6, 2] remove-if: (_ > 2)) === [1, 1, 2];
end





command list flat-map: (Fun is function-1) do
  foreign list.flatmap(self, Fun);
test
  assert ([] flat-map: { A in [A, A] }) === [];
  assert ([1, 2, 3] flat-map: { A in [A, A] }) === [1, 1, 2, 2, 3, 3];
end


command list flatten-once do
  self flat-map: { X in X };
test
  assert ([] flatten-once) === [];
  assert ([[1], [2, 3], [4, [5], 6]] flatten-once) === [1, 2, 3, 4, [5], 6];
end


// -- Folding


























// -- Zipping
command (X is list) zip: (That is list) with: (Fun is function-2)
requires same-size :: self count === That count
  = foreign list.zip-with(X, That, Fun)
test
  assert ([1, 2, 3] zip: [4, 5, 6] with: (_ + _)) === [1 + 4, 2 + 5, 3 + 6];
end


command list zip: That = self zip: That with: { A, B in [A, B] }
test
  assert ([] zip: []) =:= [];
  assert ([1] zip: [2]) =:= [[1, 2]];
  assert ([1, 2, 3] zip: [4, 5, 6]) =:= [[1, 4], [2, 5], [3, 6]];
  assert ([1, 2] zip: ["a", "b"]) === [[1, "a"], [2, "b"]];
end


// -- Sorting




// -- Other
command (X is list) without-duplicates = foreign list.unique(X)
test
  assert ([] without-duplicates) === [];
  assert ([1, 2, 1, 3, 1, 4] without-duplicates) === [1, 2, 3, 4];
end
