% crochet

// -- Constructors
command #list empty = [];













command (X is list) slice-from: (Start is integer) to: (End is integer)
requires
  positive :: Start >= 1,
  progressive :: Start <= End
  = foreign list.slice(X, Start, End)
test
  assert ([] slice-from: 1 to: 4) =:= [];
  assert ([0, 1, 2, 3] slice-from: 1 to: 4) =:= [0, 1, 2, 3];
  assert ([0, 1, 2, 3] slice-from: 1 to: 1) =:= [0];
  assert ([0, 1, 2, 3] slice-from: 4 to: 4) =:= [3];
  assert ([0, 1, 2, 3] slice-from: 2 to: 3) =:= [1, 2];
  assert ([0, 1, 2, 3] slice-from: 3 to: 5) =:= [2, 3];
end


command list slice-from: Start =
  self slice-from: Start to: (greater-of: Start and: self count)
test
  assert ([] slice-from: 1) === [];
  assert ([1] slice-from: 1) === [1];
  assert ([1, 2, 3] slice-from: 1) === [1, 2, 3];
  assert ([1, 2, 3] slice-from: 2) === [2, 3];
  assert ([1, 2, 3] slice-from: 3) === [3];
end


command list slice-to: End =
  self slice-from: 1 to: End
test
  assert ([] slice-to: 1) === [];
  assert ([1] slice-to: 1) === [1];
  assert ([1, 2, 3] slice-to: 1) === [1];
  assert ([1, 2, 3] slice-to: 2) === [1, 2];
  assert ([1, 2, 3] slice-to: 3) === [1, 2, 3];
end

command list take-while: (Fun is function-1) do
  let Go = { Xs in
    condition
      when Xs is-empty => [];
      when Fun(Xs first) => [Xs first] ++ Go(Xs rest);
      always => [];
    end
  };
  Go(self);
test
  assert ([] take-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] take-while: (_ <= 2)) === [1, 2];
  assert ([1, 2, 3, 2, 1] take-while: (_ <= 2)) === [1, 2];
end


command list drop-while: (Fun is function-1) do
  let Go = { Xs in
    condition
      when Xs is-empty => [];
      when Fun(Xs first) => Go(Xs rest);
      always => Xs;
    end
  };
  Go(self);
test
  assert ([] drop-while: (_ <= 2)) === [];
  assert ([1, 2, 3, 4] drop-while: (_ <= 2)) === [3, 4];
  assert ([1, 2, 3, 2, 1] drop-while: (_ <= 2)) === [3, 2, 1];
end


command list enumerate =
  condition
    when self is-empty => [];
    always => (1 to: self count) zip: self with: { I, V in new indexed(I, V) };
  end
test
  assert ([] enumerate) === [];
  assert (["a", "b", "c"] enumerate)
    === [new indexed(1, "a"), new indexed(2, "b"), new indexed(3, "c")];
end


// -- Collection transformations
command list keep-if: (Fun is function-1) do
  for X in self if Fun(X) do X end
test
  assert ([] keep-if: (_ > 2)) === [];
  assert ([1, 2, 3, 2, 1] keep-if: (_ > 2)) === [3];
  assert ([1, 5, 3, 1, 6, 2] keep-if: (_ > 2)) === [5, 3, 6];
end


command list remove-if: (Fun is function-1) do
  for X in self if not Fun(X) do X end;
test
  assert ([] remove-if: (_ > 2)) === [];
  assert ([1, 2, 3, 2, 1] remove-if: (_ > 2)) === [1, 2, 2, 1];
  assert ([1, 5, 3, 1, 6, 2] remove-if: (_ > 2)) === [1, 1, 2];
end


command list map: (Fun is function-1) do
  foreign list.map(self, Fun);
test
  assert ([] map: (_ + 1)) === [];
  assert ([1] map: (_ + 1)) === [2];
  assert ([1, 2, 3, 4] map: (_ + 1)) === [2, 3, 4, 5];
end


command list flat-map: (Fun is function-1) do
  foreign list.flatmap(self, Fun);
test
  assert ([] flat-map: { A in [A, A] }) === [];
  assert ([1, 2, 3] flat-map: { A in [A, A] }) === [1, 1, 2, 2, 3, 3];
end


command list flatten-once do
  self flat-map: { X in X };
test
  assert ([] flatten-once) === [];
  assert ([[1], [2, 3], [4, [5], 6]] flatten-once) === [1, 2, 3, 4, [5], 6];
end


// -- Folding
command (X is list) fold-from: Initial with: (Fun is function-2) =
  foreign list.fold(X, Initial, Fun)
test
  assert ([1, 2, 3] fold-from: 0 with: (_ + _)) =:= (1 + 2 + 3 + 0);
  assert ([] fold-from: 0 with: (_ + _)) =:= 0;
  assert ([1] fold-from: 0 with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-from: 6 with: (_ - _)) =:= (((6 - 1) - 2) - 3);
end


command (X is list) fold-right-from: Initial with: (Fun is function-2) =
  foreign list.foldr(X, Initial, Fun)
test
  assert ([] fold-right-from: 0 with: (_ + _)) =:= 0;
  assert ([1] fold-right-from: 0 with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-right-from: 6 with: (_ - _)) =:= (1 - (2 - (3 - 6)));
end


command list fold-with: (Fun is function-2)
requires non-empty :: not (self is-empty)
do
  self rest fold-from: self first with: Fun;
test
  assert ([1, 2, 3] fold-with: (_ + _)) =:= (1 + 2 + 3);
  assert ([1] fold-with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-with: (_ - _)) =:= ((1 - 2) - 3);
end


command list fold-right-with: (Fun is function-2)
requires non-empty :: not (self is-empty)
do
  self without-last fold-right-from: self last with: Fun;
test
  assert ([1] fold-right-with: (_ + _)) =:= 1;
  assert ([1, 2, 3] fold-right-with: (_ - _)) =:= (1 - (2 - 3));
end


command list some: (Fun is function-1) do
  self fold-from: false with: { A, B in A or Fun(B) };
test
  assert ([] some: (_ === 2)) === false;
  assert ([1] some: (_ === 2)) === false;
  assert ([1, 2, 3] some: (_ === 2)) === true;
  assert ([1, 2, 3, 2, 1] some: (_ === 2)) === true;
  assert ([1, 3, 1, 3, 1] some: (_ === 2)) === false;
end


command list all: (Fun is function-1) do
  self fold-from: true with: { A, B in A and Fun(B) };
test
  assert ([] all: (_ > 3)) === true;
  assert ([1] all: (_ > 3)) === false;
  assert ([1, 2, 3] all: (_ > 3)) === false;
  assert ([4, 5, 6] all: (_ > 3)) === true;
end


command list all-true = self fold-from: true with: (_ and _)
test
  assert ([] all-true) === true;
  assert ([true, true] all-true) === true;
  assert ([false] all-true) === false;
  assert ([false, true, false] all-true) === false;
end


command list some-true = self fold-from: false with: (_ or _)
test
  assert ([] some-true) === false;
  assert ([true, true] some-true) === true;
  assert ([false] some-true) === false;
  assert ([false, true, false] some-true) === true;
end


command list sum = self fold-from: 0 with: (_ + _)
test
  assert ([] sum) === 0;
  assert ([1, 2, 3, 4] sum) === (0 + 1 + 2 + 3 + 4);
end


command list product = self fold-from: 1 with: (_ * _)
test
  assert ([] product) === 1;
  assert ([1, 2, 3, 4] product) === (1 * 1 * 2 * 3 * 4);
end


command list average -> float
requires non-empty :: not (self is-empty)
  = self sum / self count
test
  assert ([3] average) === 3.0;
  assert ([1, 2, 3, 4, 5, 6, 7] average) === 4.0;
  assert ([3, 5, 8, 1, 5] average) === 4.4;
end


command list maximum
requires non-empty :: not (self is-empty)
  = self fold-with: (greater-of: _ and: _)
test
  assert ([1] maximum) === 1;
  assert ([1, 0, 2] maximum) === 2;
  assert ([-3, 5, 2, -5] maximum) === 5;
end


command list minimum
requires non-empty :: not (self is-empty)
  = self fold-with: (lesser-of: _ and: _)
test
  assert ([1] minimum) === 1;
  assert ([1, 0, 2] minimum) === 0;
  assert ([-3, 5, 2, -5] minimum) === -5;
end


// -- Zipping
command (X is list) zip: (That is list) with: (Fun is function-2)
requires same-size :: self count === That count
  = foreign list.zip-with(X, That, Fun)
test
  assert ([1, 2, 3] zip: [4, 5, 6] with: (_ + _)) === [1 + 4, 2 + 5, 3 + 6];
end


command list zip: That = self zip: That with: { A, B in [A, B] }
test
  assert ([] zip: []) =:= [];
  assert ([1] zip: [2]) =:= [[1, 2]];
  assert ([1, 2, 3] zip: [4, 5, 6]) =:= [[1, 4], [2, 5], [3, 6]];
  assert ([1, 2] zip: ["a", "b"]) === [[1, "a"], [2, "b"]];
end


// -- Sorting
command (X is list) reverse
ensures same-size :: self count === return count
  = foreign list.reverse(X)
test
  assert [] reverse =:= [];
  assert [1] reverse =:= [1];
  assert [1, 2, 3] reverse =:= [3, 2, 1];
end


command list sort-by: (Comparator is function-2)
ensures same-size :: self count === return count do
  let Compare = { A, B in
    do
      let C = Comparator(A, B);
      condition
        when C === less-than => -1;
        when C === equal => 0;
        when C === greater-than => 1;
      end
    end
  };
  foreign list.sort(self, Compare)
test
  assert ([] sort-by: (_ compare-to: _)) =:= [];
  assert ([1] sort-by: (_ compare-to: _)) =:= [1];
  assert ([-2, 1, 0, 3] sort-by: (_ compare-to: _)) =:= [-2, 0, 1, 3];
end


command (X is list) sort
ensures same-size :: self count === return count
  = self sort-by: (_ compare-to: _)
test
  assert ([] sort) =:= [];
  assert ([1] sort) =:= [1];
  assert ([-2, 1, 0, 3] sort) =:= [-2, 0, 1, 3];
end


// -- Other
command (X is list) without-duplicates = foreign list.unique(X)
test
  assert ([] without-duplicates) === [];
  assert ([1, 2, 1, 3, 1, 4] without-duplicates) === [1, 2, 3, 4];
end
