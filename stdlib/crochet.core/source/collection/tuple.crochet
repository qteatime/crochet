% crochet

command (X is tuple) count =
  foreign tuple.count(X)
test
  assert [] count =:= 0;
  assert [1] count =:= 1;
  assert [1, 2, 3] count =:= 3;
end

command (X is tuple) is-empty =
  X count =:= 0
test
  assert [] is-empty;
  assert not ([0] is-empty);
end

command (X is tuple) first
requires non-empty = not (X is-empty)
  = foreign tuple.first(X)
test
  assert [1] first =:= 1;
  assert [1, 2, 3] first =:= 1;
end

command (X is tuple) last
requires non-empty = not (X is-empty)
  = foreign tuple.last(X)
test
  assert [1] last =:= 1;
  assert [1, 2, 3] last =:= 3;
end

command (X is tuple) but-first = 
  foreign tuple.but-first(X)
test
  assert [] but-first =:= [];
  assert [1] but-first =:= [];
  assert [1, 2, 3] but-first =:= [2, 3];
end

command (X is tuple) but-last = 
  foreign tuple.but-last(X)
test
  assert [] but-last =:= [];
  assert [1] but-last =:= [];
  assert [1, 2, 3] but-last =:= [1, 2];
end

command (X is tuple) take: (N is integer)
requires positive-size = N >= 0
  = foreign tuple.take(X, N)
test
  assert ([] take: 0) =:= [];
  assert ([1, 2, 3] take: 0) =:= [];
  assert ([1, 2, 3] take: 2) =:= [1, 2];
end

command (X is tuple) drop: (N is integer)
requires positive-size = N >= 0
  = foreign tuple.drop(X, N)
test
  assert ([] drop: 0) =:= [];
  assert ([1, 2, 3] drop: 0) =:= [1, 2, 3];
  assert ([1, 2, 3] drop: 2) =:= [3];
end

command (X is tuple) ++ (Y is tuple) = 
  foreign tuple.concat(X, Y)
test
  assert ([] ++ []) =:= [];
  assert ([1, 2, 3] ++ []) =:= [1, 2, 3];
  assert ([] ++ [1, 2, 3]) =:= [1, 2, 3];
  assert ([1, 2] ++ [3, 4, 5]) =:= [1, 2, 3, 4, 5];
end

command (X is tuple) zip: (Y is tuple)
requires equal-count = X count === Y count
  = foreign tuple.zip(X, Y)
test
  assert ([] zip: []) =:= [];
  assert ([1] zip: [3]) =:= [[1, 3]];
  assert ([1, 2] zip: [3, 4]) =:= [[1, 3], [2, 4]];
end

// FIXME: not testable until algebraic effects are implemented
command (X is tuple) random-choice
requires non-empty = not (X is-empty)
ensures element-of-tuple = X contains: return
  = foreign tuple.random-choice(X)
test
  assert [1, 2, 3] random-choice;
end

// FIXME: there's no good way of describing in a contract that the
// elements of the returned tuple should be a permutation of the elements
// of the original tuple
command (X is tuple) shuffle
ensures same-size = return count === X count
  = foreign tuple.shuffle(X)
test
  let Shuffled = [1, 2, 3, 4] shuffle;
  assert Shuffled sort =:= [1, 2, 3, 4];
  assert [] shuffle =:= [];
  assert [1] shuffle =:= [1];
end

command (X is tuple) internal-sort-by: (Key is text)
ensures same-size = return count === X count
  = foreign tuple.sort-by(X, Key)
test
  let A = [[a -> 3], [a -> 1], [a -> 2]];
  assert (A internal-sort-by: "a") =:= [[a -> 1], [a -> 2], [a -> 3]];
  assert ([] internal-sort-by: "a") =:= [];
  assert ([[a -> 1]] internal-sort-by: "a") =:= [[a -> 1]];
end

command tuple sort: (Score is function-1)
ensures same-size = self count === return count
do
  let Tuple = for X in self do [score -> Score(X), value -> X] end;
  (Tuple sort-by: "score").value;
test
  assert ([] sort: { A in A }) =:= [];
  assert ([1] sort: { A in A }) =:= [1];
  assert ([3, 1, 2, 4] sort: { A in A }) =:= [1, 2, 3, 4];
end

command tuple sort
ensures same-size = self count === return count
do
  let Tuple = for X in self do [score -> X, value -> X] end;
  (Tuple sort-by: "score").value;
test
  assert [] sort =:= [];
  assert [1] sort =:= [1];
  assert [3, 1, 2, 4] sort =:= [1, 2, 3, 4];
end

command (Tuple is tuple) sort-by: (Key is text) do
  Tuple internal-sort-by: Key;
test
  assert [[a -> 1]] sort-by: "a";
end

command (X is tuple) reverse
ensures same-size = X count === return count
  = foreign tuple.reverse(X)
test
  assert [] reverse =:= [];
  assert [1] reverse =:= [1];
  assert [1, 2, 3, 4] reverse =:= [4, 3, 2, 1];
  assert [1, 2, 3, 4] reverse reverse =:= [1, 2, 3, 4];
end

command (X is tuple) fold-from: Value with: (F is function-2) =
  foreign tuple.fold(X, Value, F)
test
  assert ([] fold-from: 0 with: (_ + _)) =:= 0;
  assert ([1] fold-from: 0 with: (_ + _)) =:= (0 + 1);
  assert ([1, 2, 3] fold-from: 0 with: (_ + _)) =:= (0 + 1 + 2 + 3);
end

command tuple non-empty-fold-with: (F is function-2)
requires non-empty = not (self is-empty)
do
  self but-first fold-from: self first with: F;
test
  assert ([3, 2, 1] non-empty-fold-with: (_ - _)) =:= 0;
end

command tuple flatten
  = self fold-from: [] with: (_ ++ _)
test
  assert [] flatten =:= [];
  assert [[1]] flatten =:= [1];
  assert [[1], [2, 3], [4, [5]]] flatten =:= [1, 2, 3, 4, [5]];
end

command tuple sum
  = self fold-from: 0 with: (_ + _)
test
  assert [] sum =:= 0;
  assert [1] sum =:= 1;
  assert [1, 2, 3] sum =:= 6;
  assert [-1, 0, 1, 2] sum =:= 2;
end

// FIXME: this will be removed and moved to a proper linguistics package
command tuple join-text-with: Separator =
  condition
    when self is-empty => "";
    always =>
      self but-first
        fold-from: self first
        with: { A, B in A ++ Separator ++ B };
  end
test
  assert (["a", "b", "c"] join-text-with: " and ")
    =:= "a and b and c";
end

command (X is tuple) interpolate =
  foreign tuple.interpolate(X);

command (X is tuple) contains: V =
  foreign tuple.contains(X, V)
test
  assert not ([] contains: 1);
  assert [1] contains: 1;
  assert [-1, 0, 1, 2, 3] contains: 1;
  assert not ([-1, 0, 1, 2, 3] contains: -2);
end