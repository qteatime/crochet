% crochet

// -- Record

implement modifiable-mapped-container for record;

/// Returns a new record where [Key] is now associated with [Value].
command record at: (Key is text) put: Value =
  foreign record.at-put(self, Key, Value)
test
  let A = [a -> 1, b -> 2];
  assert ([->] at: "a" put: 1) === [a -> 1];
  assert (A at: "a" put: 2) === [a -> 2, b -> 2];
  assert A === [a -> 1, b -> 2];
  assert (A at: "c" put: 3) === [a -> 1, b -> 2, c -> 3];
end

/// Returns a new record where the value identified by [Key] is transformed
/// acording to the provided [Fun].
command record at: (Key is text) update: (Fun is function-1) do
  condition
    when self contains-key: Key =>
      self at: Key put: Fun(self.[Key]);
    always =>
      self;
  end
test
  assert ([->] at: "a" update: (_ + 1)) === [->];
  assert ([a -> 1] at: "a" update: (_ + 1)) === [a -> 2];
  assert ([a -> 1, b -> 2] at: "a" update: (_ + 1)) === [a -> 2, b -> 2];
  assert ([a -> 1, b -> 2] at: "c" update: (_ + 1)) === [a -> 1, b -> 2];
end

/// Returns a new record where the value identified by [Key] is transformed
/// by the provided [Fun], if it exists. Otherwise, associates [Key] with
/// the provided default [Value].
command record at: (Key is text) default: Value update: (Fun is function-1) do
  condition
    when self contains-key: Key =>
      self at: Key put: Fun(self.[Key]);
    always =>
      self at: Key put: Value;
  end
test
  assert ([->] at: "a" default: 1 update: (_ + 1)) === [a -> 1];
  assert ([a -> 1] at: "a" default: 1 update: (_ + 1)) === [a -> 2];
  assert ([a -> 1, b -> 2] at: "a" default: 1 update: (_ + 1)) === [a -> 2, b -> 2];
  assert ([a -> 1, b -> 2] at: "c" default: 1 update: (_ + 1)) === [a -> 1, b -> 2, c -> 1];
end

/// Returns a new record that no longer associates the given [Key] with any
/// value.
command record remove-at: (Key is text) =
  foreign record.delete-at(self, Key)
test
  assert ([a -> 1] remove-at: "a") === [->];
  assert ([a -> 1, b -> 2] remove-at: "a") === [b -> 2];
end

// -- Map
implement modifiable-mapped-container for map;

command map at: Key put: Value do
  new map(foreign map.set(self.box, Key, Value));
test
  assert (#map empty | at: 1 put: 2 | at: 1) === 2;
  assert not (#map empty | at: 1 put: 2 | contains-key: 2);
  assert (#map empty | at: 1 put: 2 | at: 2 put: 3) ===
    (#map from: [
      #association key: 1 value: 2,
      #association key: 2 value: 3,
    ]);
  assert (#map empty | at: 1 put: 2 | at: 1 put: 3 | at: 1) === 3;
end

command map at: Key update: (Transformation is (A -> B)) do
  condition
    when self contains-key: Key => self at: Key put: Transformation(self at: Key);
    always => self;
  end
test
  assert not (#map empty | at: 1 update: (_ + 1) | contains-key: 1);
  assert (#map empty | at: 1 put: 2 | at: 1 update: (_ + 1) | at: 1) === 3;
end

command map remove-at: Key do
  new map(foreign map.remove(self.box, Key));
test
  assert (#map empty | remove-at: 1) === #map empty;
  assert (#map empty | at: 1 put: 2 | remove-at: 1) === #map empty;
  assert (#map empty | at: 1 put: 2 | at: 3 put: 4 | remove-at: 1) === (#map empty | at: 3 put: 4);
end