% crochet

command (X is stream) count =
  foreign stream.count(X);

command (X is stream) is-empty =
  X count === 0;

command (X is stream) first =
  foreign stream.first(X);

command (X is stream) last =
  foreign stream.last(X);

command (X is stream) but-first = 
  foreign stream.but-first(X);

command (X is stream) but-last = 
  foreign stream.but-last(X);

command (X is stream) take: (N is integer) = 
  foreign stream.take(X, N);

command (X is stream) drop: (N is integer) = 
  foreign stream.drop(X, N);

command (X is stream) ++ (Y is stream) = 
  foreign stream.concat(X, Y);

command (X is stream) zip: (Y is stream) = 
  foreign stream.zip(X, Y);

command (X is stream) random-choice =
  foreign stream.random-choice(X);

command (X is stream) shuffle =
  foreign stream.shuffle(X);

command (X is stream) internal-sort-by: Key =
  foreign stream.sort-by(X, Key);

command stream sort: (Score is partial) do
  let Stream = for X in self do [score -> Score(X), value -> X] end;
  (Stream sort-by: "score").value;
end

command stream sort do
  let Stream = for X in self do [score -> X, value -> X] end;
  (Stream sort-by: "score").value;
end

command (Stream is stream) sort-by: (Key is text) do
  Stream internal-sort-by: Key;
end

command (X is stream) reverse =
  foreign stream.reverse(X);

command (X is stream) fold-from: Value with: (Partial is partial) =
  foreign stream.fold(X, Value, Partial);

command stream flatten = self fold-from: [] with: (_ ++ _);
command stream sum = self fold-from: 0 with: (_ + _);

command stream join-text-with: Separator =
  stream fold-from: "" with: (_ ++ _);

command (X is stream) interpolate =
  foreign stream.interpolate(X);

command (X is stream) contains: V =
  foreign stream.contains(X, V);