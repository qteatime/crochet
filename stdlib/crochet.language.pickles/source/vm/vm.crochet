% crochet

type pickles-vm(
  globals is environment,
  modules is cell<map<text, pickles-module>>,
);

command #pickles-vm make =
  new pickles-vm(
    globals -> #pickles globals,
    modules -> #cell with-value: #map empty,
  );

command #pickles-vm exception: (Error is pickles-error) =
  perform pickles-evaluation.exception(Error);



command pickles-vm load-module: (Ast is ast-module) do
  let Env = self.globals clone,
  let Definitions = Ast.declarations map: (package evaluate-declaration: _ in: Env);
  for Definition in Definitions do
    Env define: Definition.name as: Definition;
  end

  let Module =
    new pickles-module(
      name -> Ast.name,
      environment -> Env,
      exports -> #set from: (Definitions map: { X in X.name }),
    );

  self.modules <- self.modules value at: Module name put: Module;
  self;
end

command package evaluate-declaration: (X is ast-declaration--let) in: (Env is environment) =
  new pickles-parser(
    name -> X.name,
    body -> X.body,
    location -> X.info,
    environment -> Env,
  );

command package evaluate-declaration: (X is ast-declaration--letfun) in: (Env is environment) =
  new pickles-function(
    name -> X.name,
    formals -> X.formals,
    body -> X.body,
    location -> X.info,
    environment -> Env,
  );


command pickles-vm lookup-module: (Name is text) do
  let Modules = self.modules value;
  condition
    when Modules contains-key: Name => Modules at: Name;
    otherwise => #pickles-vm exception: new pickles-error--module-not-found(Name);
  end
end