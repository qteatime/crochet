% crochet

abstract ljt-error;

command #ljt-error raise: (Error is ljt-error) =
  perform ljt-error.raise(Error);


effect ljt-error with
  raise(error is ljt-error); // -> any
end

handler ljt-fail-fast with
  on ljt-error.raise(Error) do
    panic message: Error to-panic-message tag: "ljt-error" data: [error -> Error];
  end
end

default handler ljt-fail-fast;


type ljt-error--duplicated-binding(
  global name is text,
  global value is any,
  environment is ljt-env
) is ljt-error;

command ljt-error--duplicated-binding to-panic-message =
  "Binding [self.name] is already defined.";


type ljt-error--no-binding(
  global name is text,
  environment is ljt-env
) is ljt-error;

command ljt-error--no-binding to-panic-message =
  "No binding [self.name] found.";


type ljt-error--duplicated-type(
  global new-type :: t-tagged,
  vm is ljt-vm
) is ljt-error;

command ljt-error--duplicated-type to-panic-message =
  "Type [self.new-type short-representation] is already defined.";


type ljt-error--duplicated-tag(
  global tag is integer,
  global offending-type is t-tagged,
  vm is ljt-vm,
) is ljt-error;

command ljt-error--duplicated-tag to-panic-message do
  let Type = self.vm.tag-map value at: self.tag;
  "Type [self.offending-type short-representation] has tag [self.tag to-text], but that's already taken by type [Type short-representation]";
end