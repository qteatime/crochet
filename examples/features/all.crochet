% crochet

role actor;
role room;

command X inspect = inspect(X);

command (X is integer) hello do
  "Numbers can't say anything, miss...";
end

singleton lielle :: actor with
  at: foyer;
  likes: kristine;

  command hello do
    "Lielle: hello!";
  end
end

singleton kristine :: actor with
  at: foyer;

  command hello do
    "Kristine: hi.";
  end
end

singleton foyer :: room;

relation Who* at: Where;
relation Who* likes: Whom*;
relation Who* disabled;

predicate Who kisses: Whom at: Where do
  when Who at: Where, Whom at: Where, Who likes: Whom;
end

prelude
  let Kisses = search lielle kisses: (Who :: actor) at: (Where :: room);
  let Multi = "This is
               a multiline
          text alright
                  a bit weird tho";
  [
    Hello -> [
      (lielle hello as stream) as stream,
      kristine hello as unknown,
      1 hello as any
    ],
    Search -> Kisses,
  ];
  Multi inspect;
end

scene one do
  "One" inspect;
  call two;
  "One end" inspect;
end

scene two do
  "Two" inspect;
end

scene main do
  "Hello" inspect;
  simulate for [kristine, lielle] until action quiescence
    on pick-action: Actions for: Turn do
      "Simulate for [Turn] with [Actions.Title]" inspect;
      Actions first;
    end;
  call one;
  goto two;
  "End" inspect;
end

action "Say hello"
when X simulate-turn, not X disabled, X at: P, Y at: P, if X =/= Y do
  [X, "says hello to", Y] inspect;
  ["Stats", search Turn simulate-turn, Rounds simulate-rounds-elapsed] inspect;
  ["Acted", search X simulate-acted] inspect;
  ["Remaining", (search X simulate-actor, not X simulate-acted, not X simulate-turn)] inspect;
  fact X disabled;
end

action "Say goodbye"
when X simulate-turn, not X action-fired: _ do
  "[X] says goodbye" inspect;
end

when X simulate-turn do
  [X, "ends her turn"] inspect;
end
