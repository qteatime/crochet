% crochet

role actor;
role room;

command X inspect = inspect(X);
command (X is integer) hello { "Numbers can't say anything, miss..."; }

singleton lielle :: actor {
  at: foyer;
  likes: kristine;

  command hello {
    "Lielle: hello!";
  }
}

singleton kristine :: actor {
  at: foyer;

  command hello {
    "Kristine: hi.";
  }
}

singleton foyer :: room;

relation Who* at: Where;
relation Who* likes: Whom*;
relation Who* disabled;

predicate Who kisses: Whom at: Where {
  when Who at: Where, Whom at: Where, Who likes: Whom;
}

do {
  let Kisses = search lielle kisses: (Who :: actor) at: (Where :: room);
  let Multi = "This is
               a multiline
          text alright
                  a bit weird tho";
  [
    Hello -> [
      (lielle hello as stream) as stream,
      kristine hello as unknown,
      1 hello as any
    ],
    Search -> Kisses,
  ];
  Multi inspect;
}

scene one {
  "One" inspect;
  call two;
  "One end" inspect;
}

scene two {
  "Two" inspect;
}

scene main {
  "Hello" inspect;
  simulate for [kristine, lielle] until action quiescence
    on pick-action: Actions for: Turn {
      "Simulate for [Turn] with [Actions.Title]" inspect;
      Actions first;
    };
  call one;
  goto two;
  "End" inspect;
}

action "Say hello"
when X simulate-turn, not X disabled, X at: P, Y at: P if X =/= Y {
  [X, "says hello to", Y] inspect;
  ["Stats", search Turn simulate-turn, Rounds simulate-rounds-elapsed] inspect;
  ["Acted", search X simulate-acted] inspect;
  ["Remaining", (search X simulate-actor, not X simulate-acted, not X simulate-turn)] inspect;
  fact X disabled;
}

action "Say goodbye"
when X simulate-turn, not X action-fired: _ {
  "[X] says goodbye" inspect;
}

when X simulate-turn {
  [X, "ends her turn"] inspect;
}
