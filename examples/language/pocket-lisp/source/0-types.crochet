% crochet

// # The types that make Pocket Lisp
//
// This file defines most of the types that make up the Pocket Lisp
// implementation. Sadly, it only exists due to a current limitation
// of the Crochet implementation around mutual recursion[1]. Putting
// them all here makes it hard to see their context, but such is life.
//
// ---
// [1]: https://github.com/qteatime/crochet/issues/10

// ## A brief note on external types
//
// We'll use the `interval` type from the Lingua runtime. This is the type that
// encodes the source position information on things that have been parsed
// with Lingua grammars. The way we refer to external types is by bringing
// them into scope with the `open` declaration---it's not currently possible
// to be more specific, so conflicts are handled on a "the last declared name
// wins" basis.
//
open crochet.text.parsing.lingua;


// ## The Pocket Lisp runtime
//
// The Pocket Lisp implementation reuses most of the things the Crochet
// runtime provides, including its intrinsic types. We could very well
// live with exposing the Crochet types directly, but that would make
// it harder to differentiate Crochet-related errors from Pocket Lisp-related
// errors.
//
// For example, Pocket Lisp does not have multi-methods, and an operation
// like `+` is only available to integers---not strings, not booleans, not lists.
// Having a separate type hierarchy here helps us achieve that in a cuter way,
// as we can define all of these infix methods over the Pocket Lisp types and
// use it in the implementation of our primitive operations---rather than a
// more contrived thing such as `pocket-lisp add: X to: Y`, we can have just
// `X + Y`.
//
// The root of our hierarchy is the `value` type. Pocket Lisp is dynamically
// typed, which means that everything is a `value`, and every value has an
// additional bit of information which specifies how we should be interpreting
// it. This is often called the "runtime tag" in literature, but informally
// also called the "dynamic type" of the value. In our case we rely on
// Crochet's subtyping capabilities and make distinct Crochet types for
// each Pocket Lisp type, all descending from `value`.
//
// The primary reason for this is that we can rely on any dispatch
// optimisations that Crochet has, and on all of the multi-method and
// security/privacy goodies---even though Pocket Lisp does not care about
// security in the same way Crochet does.
//
// The `value` type is an abstract type because we don't want anyone
// constructing `value`---`value` itself doesn't make sense in Pocket Lisp.
//
abstract value;

// ## The Pocket Lisp environment
//
// We take a brief detour here. Because the current implementation of Crochet
// has certain limitations around mutually-recursive definitions, we need to
// either give up on (runtime) type checking of fields, or re-order our
// definitions such that the types are available when we mention them in
// another definition.
//
// This example takes the second approach and defines the `environment`
// before it defines the rest of the intrinsic types.
//
// The `environment` is how we keep track of what names map to what values
// in Pocket Lisp. And in Pocket Lisp, this environment can change in
// response to `(define ...)` forms. We choose to support this by making
// the `bindings` field of the environment mutable. The `cell` type provides
// a mutable piece of memory with atomic writing guarantees. Most other
// types in Crochet (including most collections) are immutable and persistent,
// so we just keep replacing the value of this cell with an entire new
// collection every time it changes.
//
// The other way of approaching this would be to linearise the evaluation,
// such that we could construct a new environment and pass it to the rest
// of the program once we evaluate a form. The mutable approach is slightly
// simpler here.
//
// Pocket Lisp names exist in different lexical regions---a lexical region
// is a function in Pocket Lisp. For example, consider the following program:
//
//     (define add [a] ;; Region 1
//       (define go [b] ;; Region 2
//         (+ a b)))
//
// In Region 1 we define the name `a`, and in Region 2 we define the name
// `b`. However, we also access the name `a` in Region 2! Thus we need a
// way of accessing Region 1 names inside of Region 2. The way this
// implementation chooses to do is through tiered lookups: we start looking
// into Region 2's bindings, and if we can't find it we'll look into
// Region 1's bindings, and then in the global bindings, before we give up.
//
// The `parent` field then exists to answer the question "if we don't find
// a name here, where else should we look for it?".
//
// Note that here we don't have a type for `parent`. This is a limitation
// of Crochet where we currently can't provide proper contracts in field
// definitions. The `parent` field can hold either another environment, or
// the value `nothing`, but there's no way of expressing `environment or nothing`
// yet in Crochet. So it becomes untyped instead.
//
//
// ### Why not copy the bindings?
//
// One thing that might spring to one's mind regarding the tiered lookup is:
// "why don't we just copy the previous bindings when constructing a new region?"
// A very valid question, since, with persistent maps we get this "copy" for
// free---just pass the whole map around and any new addition to the map will
// construct a whole new one (cheaply). We also don't pay the price of walking
// up the regions trying to find a name.
//
// So why don't we do that here?
//
// The reason is really that Pocket Lisp wants its bindings to be mutable.
// Consider:
//
//     (define inc [x]
//       (define go [] (+ x amount))
//       (define amount 1)
//       (go))
//
// If we were to copy the bindings here, `go` wouldn't have a definition for
// `amount`, because we only create that binding later! We would need
// to do some pre-processing on our AST here to figure out what we need to
// copy---mutually recursive definitions are a common thing, and Pocket Lisp
// avoids providing a `(let-recursive [...] ...)` construct, where one would
// define all of the names that refer to others, in favour of having mutable
// bindings along with late bound names.
// 
type environment(parent, bindings is cell<map<text, value>>);

type p-integer(value is integer) is value;
type p-string(value is text) is value;

abstract p-boolean;
singleton p-true is p-boolean;
singleton p-false is p-boolean;

abstract p-list is value;
singleton p-nil is p-list;
type p-cons(head is value, tail is p-list) is p-list;

abstract procedure is value;
type p-procedure(pos is interval, env is environment, name is text, parameters is list<text>, body is list<plisp-form>) is procedure;
type p-native-procedure(name is text, arity, handler is (list<value> -> value)) is procedure;

singleton vm;
type frame(parent, environment, location);

abstract plisp-error;
type error-undefined-variable(name is text) is plisp-error;
type error-already-bound(name is text, value is value) is plisp-error;
type error-invalid-arity(expected is integer, arguments is list<value>, target is procedure) is plisp-error;
type error-native(code is text, reason is text, data) is plisp-error;

effect pocket-lisp with
  // Raise an error
  raise(frame is frame, form is plisp-form, error is plisp-error);
  raw-raise(error is plisp-error);
end