% crochet

singleton erin with
  command mark do "X" end
  command name do "Erin" end
end

singleton saga with
  command mark do "O" end
  command name do "Saga" end
end

singleton empty with
  command mark do "_" end
end

singleton board with
  command render do
    let S = (search l1 c1: M11 c2: M12 c3: M13,
                    l2 c1: M21 c2: M22 c3: M23,
                    l3 c1: M31 c2: M32 c3: M33) first;
    monospace:
      "
      [S.M11 mark]|[S.M12 mark]|[S.M13 mark]
      [S.M21 mark]|[S.M22 mark]|[S.M23 mark]
      [S.M31 mark]|[S.M32 mark]|[S.M33 mark]
      ";
  end
end

type line;
singleton l1 is line with
  command to-html do "L1" text end
end
singleton l2 is line with
  command to-html do "L2" text end
end
singleton l3 is line with
  command to-html do "L3" text end
end

type column;
singleton c1 is column with
  command to-html do "C1" text end
end
singleton c2 is column with
  command to-html do "C2" text end
end
singleton c3 is column with
  command to-html do "C3" text end
end

type state;
singleton on-going is state;
singleton won is state;
singleton draw is state;

relation Line* at: Column* mark: Who;
relation State state;
relation Who player;

define lines = [l1, l2, l3];
define columns = [c1, c2, c3];


predicate Line c1: M1 c2: M2 c3: M3 do
  when Line at: c1 mark: M1,
       Line at: c2 mark: M2,
       Line at: c3 mark: M3;
end


prelude
  for L in lines do
    for C in columns do
      fact L at: C mark: empty;
    end
  end;

  fact on-going state;
end


predicate X won do
  when L at: c1 mark: X,
       L at: c2 mark: X,
       L at: c3 mark: X;
  
  when l1 at: C mark: X,
       l2 at: C mark: X,
       l3 at: C mark: X;

  when l1 at: c1 mark: X,
       l2 at: c2 mark: X,
       l3 at: c3 mark: X;
  
  when l1 at: c3 mark: X,
       l2 at: c2 mark: X,
       l3 at: c1 mark: X;
end

scene main do
  (header: [
    title: "Tic-Tac-Toe",
    subtitle: "A small example of AI-driven game",
  ]) show;

  let PlayerSelection = menu: [
    [
      Title -> "Saga ([saga mark])",
      Value -> saga
    ],
    [
      Title -> "Erin ([erin mark])",
      Value -> erin
    ]
  ];

  (paragraph: [
    "Choose a character to play as:",
    PlayerSelection
  ]) show;

  fact (PlayerSelection selected) player;

  simulate for [erin, saga]
  until not on-going state
  on pick-action: Actions for: Turn do
    match
      when Turn player do
        let Items = for Action in Actions do
          [Title -> Action.Title, Value -> Action]
        end;
        (menu: Items) show selected;
      end

      always do
        Actions random-choice;
      end
    end first;
  end;
end

action "Mark [L], [C]"
when X simulate-turn, L at: C mark: empty do
  fact L at: C mark: X;

  (section: [
    "[X name] marks [L], [C]",
    board render,
  ]) show;
  100 sleep;
end

when X simulate-turn, X won do
  "[X name] won!" show;
  fact won state;
end

when on-going state, not X won, not L at: C mark: empty do
  "It's a draw!" show;
  fact draw state;
end
