type Program(pos: Meta, declarations: Declaration[])

type Declaration =
  | Relation(pos: Meta, signature: Signature<RelationPart>)
  | DefinePredicate(pos: Meta, signature: Signature<Name>, clauses: PredicateClause[])
  | Do(pos: Meta, body: Statement[])
  | ForeignCommand(pos: Meta, signature: Signature<Parameter>, body: FFI)
  | Command(pos: Meta, signature: Signature<Parameter>, body: Statement[])
  | Define(pos: Meta, name: Name, value: Expression)  // requires atomicity
  | Role(pos: Meta, name: Name)
  | SingletonType(pos: Meta, typ: TypeDef, init: TypeInit[])
  | ForeignType(pos: Meta, name: Name, foreign_name: Namespace)
  | Type(pos: Meta, typ: TypeDef, fields: Parameter[])
  | Scene(pos: Meta, name: Name, body: Statement[])
  | Action(pos: Meta, title: Interpolation<Name>, tags: Name[], pred: Predicate, rank: Rank, body: Statement[])
  | When(pos: Meta, pred: Predicate, body: Statement[])

type TypeDef(parent: TypeApp?, name: Name, roles: Name[])
type FFI(pos: Meta, name: Namespace, args: Name[])

type Rank =
  | Expr(expr: Expression)
  | Unranked(pos: Meta)

type TypeInit =
  | Fact(pos: Meta, sig: PartialSignature<Expression>)
  | Command(pos: Meta, sig: PartialSignature<Parameter>, body: Statement[])
  | ForeignCommand(pos: Meta, signature: PartialSignature<Parameter>, body: FFI)

type Parameter =
  | Untyped(pos: Meta, name: Name)
  | Typed(pos: Meta, name: Name, typ: TypeApp)
  | TypedOnly(pos: Meta, typ: TypeApp)

type TypeApp =
  | Named(pos: Meta, name: Name)

type PredicateClause(
  pos: Meta,
  predicate: Predicate,
  effect: PredicateEffect
)

type PredicateEffect =
  | Trivial()

type Statement =
  | Fact(pos: Meta, signature: Signature<Expression>)
  | Forget(pos: Meta, signature: Signature<Expression>)
  | Goto(pos: Meta, name: Name)
  | Call(pos: Meta, name: Name)
  | Let(pos: Meta, name: Name, value: Expression)
  | SimulateGlobal(pos: Meta, actors: Expression, goal: SimulationGoal, signals: Signal[])
  | Expr(value: Expression)

type Signal(pos: Meta, signature: Signature<Parameter>, body: Statement[])

type Expression =
  | New(pos: Meta, typ: Name, fields: Expression[])
  | Invoke(pos: Meta, signature: Signature<Expression>)
  | Global(pos: Meta, name: Name)
  | Variable(pos: Meta, name: Name)
  | Self(pos: Meta)
  | List(pos: Meta, values: Expression[])
  | Record(pos: Meta, pairs: Pair<RecordField, Expression>[])
  | Cast(pos: Meta, typ: TypeApp, value: Expression)
  | Search(pos: Meta, predicate: Predicate)
  | MatchSearch(pos: Meta, cases: MatchSearchCase[])
  | Project(pos: Meta, object: Expression, field: RecordField)
  | Select(pos: Meta, object: Expression, fields: Projection[])
  | For(pos: Meta, stream: Expression, name: Name, body: Expression)
  | Block(pos: Meta, body: Statement[])
  | Apply(pos: Meta, partial: Expression, values: Expression[])
  | Pipe(pos: Meta, left: Expression, right: Expression)
  | Interpolate(pos: Meta, value: Interpolation<Expression>)
  | Condition(pos: Meta, cases: ConditionCase[])
  | HasType(pos: Meta, value: Expression, typ: TypeApp)
  | HasRole(pos: Meta, value: Expression, role: Name)
  | Hole(pos: Meta)
  | Parens(pos: Meta, value: Expression)
  | Lit(value: Literal)

type MatchSearchCase(pos: Meta, predicate: Predicate, body: Statement[])
type ConditionCase(pos: Meta, guard: Expression, body: Statement[])

type RecordField =
  | FName(value: Name)
  | FText(value: String)

type Projection(pos: Meta, name: RecordField, alias: RecordField)

type Interpolation<T>(pos: Meta, parts: InterpolationPart<T>[])

type InterpolationPart<T> =
  | Escape(pos: Meta, character: string)
  | Static(pos: Meta, text: string)
  | Dynamic(pos: Meta, value: T)

type Literal =
  | False(pos: Meta)
  | True(pos: Meta)
  | Text(pos: Meta, value: String)
  | Integer(pos: Meta, digits: string)

type SimulationGoal =
  | ActionQuiescence(pos: Meta)
  | EventQuiescence(pos: Meta)
  | TotalQuiescence(pos: Meta)
  | CustomGoal(pos: Meta, pred: Predicate)

type Predicate =
  | And(pos: Meta, left: Predicate, right: Predicate)
  | Or(pos: Meta, left: Predicate, right: Predicate)
  | Not(pos: Meta, pred: Predicate)
  | Has(pos: Meta, signature: Signature<Pattern>)
  | Constrain(pos: Meta, pred: Predicate, constraint: Constraint)
  | Always(pos: Meta)
  | Parens(pos: Meta, pred: Predicate)

type Pattern =
  | HasRole(pos: Meta, typ: Name, name: Pattern)
  | HasType(pos: Meta, typ: TypeApp, name: Pattern)
  | Global(pos: Meta, name: Name)
  | Variable(pos: Meta, name: Name)
  | Self(pos: Meta)
  | Wildcard(pos: Meta)
  | Lit(lit: Literal)

type Constraint =
  | And(pos: Meta, left: Constraint, right: Constraint)
  | Or(pos: Meta, left: Constraint, right: Constraint)
  | Not(pos: Meta, value: Constraint)
  | Equal(pos: Meta, left: Constraint, right: Constraint)
  | Variable(pos: Meta, name: Name)
  | Global(pos: Meta, name: Name)
  | HasRole(pos: Meta, value: Constraint, role: Name)
  | HasType(pos: Meta, value: Constraint, typ: TypeApp)
  | Parens(pos: Meta, value: Constraint)
  | Lit(lit: Literal)

type Signature<T> =
  | Unary(pos: Meta, self: T, name: Name)
  | Binary(pos: Meta, op: Name, left: T, right: T)
  | Keyword(pos: Meta, self: T, pairs: Pair<Name, T>[])
  | KeywordSelfless(pos: Meta, pairs: Pair<Name, T>[])

type PartialSignature<T> =
  | Unary(pos: Meta, name: Name)
  | Binary(pos: Meta, op: Name, right: T)
  | Keyword(pos: Meta, pairs: Pair<Name, T>[])

type RelationPart =
  | Many(pos: Meta, name: Name)
  | One(pos: Meta, name: Name)

type Pair<K, V>(pos: Meta, key: K, value: V)
type Name(pos: Meta, name: string)
type Namespace(pos: Meta, names: string[])
type String(pos: Meta, text: string)


grammar Crochet : Program {
  program =
    | header ds:declaration* space* end
      -> Program(meta, ds)

  declaration =
    | relationDeclaration
    | predicateDeclaration
    | doDeclaration
    | commandDeclaration
    | roleDeclaration
    | typeDeclaration
    | defineDeclaration
    | sceneDeclaration
    | actionDeclaration
    | whenDeclaration

  relationDeclaration =
    | relation_ s:logicSignature<relationPart> s<";">
      -> Declaration.Relation(meta, s)

  relationPart =
    | n:name s<"*"> -> RelationPart.Many(meta, n)
    | n:name        -> RelationPart.One(meta, n)

  predicateDeclaration =
    | predicate_ l:logicSignature<name> c:block<predicateClause>
      -> Declaration.DefinePredicate(meta, l, c)

  predicateClause =
    | when_ p:predicate s<";">    -> PredicateClause(meta, p, PredicateEffect.Trivial())
    | always_ p:predicate s<";">  -> PredicateClause(meta, Predicate.Always(meta), PredicateEffect.Trivial())

  doDeclaration =
    | prelude_ xs:list0<statement, s<";">> end_
      -> Declaration.Do(meta, xs)

  commandDeclaration =
    | command_ s:signature<parameter> s<"="> foreign_ b:foreignBody
      -> Declaration.ForeignCommand(meta, s, b)

    | command_ s:signature<parameter> s<"="> e:expression s<";">
      -> Declaration.Command(meta, s, [Statement.Expr(e)])

    | command_ s:signature<parameter> b:statementBlock<statement>
      -> Declaration.Command(meta, s, b)

  foreignBody =
    | n:namespace s<"("> xs:list0<name, s<",">> s<")"> s<";">
      -> FFI(meta, n, xs)

  parameter =
    | n:name                              -> Parameter.Untyped(meta, n)
    | s<"("> n:name is_ t:typeApp s<")">  -> Parameter.Typed(meta, n, t)
    | t:typeName                          -> Parameter.TypedOnly(meta, TypeApp.Named(meta, t))

  typeApp =
    | typeAppPrimary

  typeAppPrimary =
    | t:typeName                  -> TypeApp.Named(meta, t)

  typeName =
    | atom
    | x:true_   -> Name(meta, x)
    | x:false_  -> Name(meta, x)

  typeDeclaration =
    | singleton_ t:basicType i:typeInitBlock
      -> Declaration.SingletonType(meta, t, i)

    | type_ t:basicType fs:typeFields s<";">
      -> Declaration.Type(meta, t, fs)

    | type_ n:typeName s<"="> foreign_ ns:namespace s<";">
      -> Declaration.ForeignType(meta, n, ns)
  
  basicType =
    | n:atom p:typeDefParent r:roles    -> TypeDef(p, n, r)

  typeDefParent =
    | is_ t:typeApp   -> t
    |                 -> null

  typeInitBlock =
    | with_ x:typeInit* end_    -> x
    | s<";">                    -> []

  typeFields =
    | s<"("> fs:list1<typeField, s<",">> s<")">  -> fs
    |                                            -> []

  typeField =
    | n:name is_ t:typeApp                -> Parameter.Typed(meta, n, t)
    | n:name                              -> Parameter.Untyped(meta, n)

  typeInit =
    | s:partialLogicSignature<invokePostfix> s<";">
      -> TypeInit.Fact(meta, s)
    | command_ s:partialSignature<parameter> s<"="> b:foreignBody
      -> TypeInit.ForeignCommand(meta, s, b)
    | command_ s:partialSignature<parameter> b:statementBlock<statement>
      -> TypeInit.Command(meta, s, b)

  roleDeclaration =
    | role_ n:atom s<";">           -> Declaration.Role(meta, n)

  roles =
    | s<"::"> r:nonemptyListOf<atom, s<",">>   -> r
    |                                          -> []

  defineDeclaration =
    | define_ n:atom s<"="> e:atomicExpression s<";">
      -> Declaration.Define(meta, n, e)

  sceneDeclaration =
    | scene_ n:atom b:statementBlock<statement>
      -> Declaration.Scene(meta, n, b)

  actionDeclaration =
    | action_ t:interpolateText<name>
        tags:actionTags
        p:actionPredicate
        r:actionRank
        b:statementBlock<statement>
      -> Declaration.Action(meta, t, tags, p, r, b)
  
  actionTags =
    | tags_ es:list1<atom, s<",">> -> es
    |                              -> []


  actionPredicate =
    | when_ p:predicate -> p
    |                   -> Predicate.Always(meta)

  actionRank =
    | rank_ e:expression -> Rank.Expr(e)
    |                    -> Rank.Unranked(meta)

  whenDeclaration =
    | when_ p:predicate b:statementBlock<statement>
      -> Declaration.When(meta, p, b)


  // -- Logic
  predicate =
    | predicateBinary

  predicateBinary =
    | predicateAnd
    | predicateOr
    | predicateNot

  predicateAnd =
    | l:predicateNot s<","> r:predicateAnd1   -> Predicate.And(meta, l, r)
  
  predicateAnd1 =
    | l:predicateNot s<","> r:predicateAnd1   -> Predicate.And(meta, l, r)
    | predicateNot

  predicateOr =
    | l:predicateNot s<"|"> r:predicateOr1    -> Predicate.Or(meta, l, r)
  
  predicateOr1 =
    | l:predicateNot s<"|"> r:predicateOr1    -> Predicate.Or(meta, l, r)
    | predicateNot
  
  predicateNot =
    | not_ p:predicateConstrain               -> Predicate.Not(meta, p)
    | predicateConstrain

  predicateConstrain =
    | p:predicatePrimary if_ c:constraint      -> Predicate.Constrain(meta, p, c)
    | predicatePrimary

  predicatePrimary =
    | always_                                 -> Predicate.Always(meta)
    | r:logicSignature<pattern>               -> Predicate.Has(meta, r)
    | s<"("> p:predicate s<")">               -> Predicate.Parens(meta, p)

  pattern =
    | s<"("> c:patternComplex s<")">  -> c
    | n:atom                  -> Pattern.Global(meta, n)
    | self_                   -> Pattern.Self(meta)
    | l:literal               -> Pattern.Lit(l)
    | patternName

  patternComplex =
    | n:patternName is_ t:typeApp   -> Pattern.HasType(meta, t, n)
    | n:patternName s<"::"> t:atom  -> Pattern.HasRole(meta, t, n)

  patternName =
    | s<"_">        -> Pattern.Wildcard(meta)
    | n:name        -> Pattern.Variable(meta, n)

  constraint =
    | l:constraint and r:constraint  -> Constraint.And(meta, l, r)
    | l:constraint or r:constraint   -> Constraint.Or(meta, l, r)
    | constraint200

  constraint200 =
    | not_ c:constraint300            -> Constraint.Not(meta, c)
    | constraint300

  constraint300 =
    | l:constraint400 s<"==="> r:constraint400  -> Constraint.Equal(meta, l, r)
    | l:constraint400 s<"=/="> r:constraint400  -> Constraint.Not(meta, Constraint.Equal(meta, l, r))
    | constraint400

  constraint400 =
    | l:constraint500 s<"::"> r:atom  -> Constraint.HasRole(meta, l, r)
    | l:constraint500 is_ t:typeApp   -> Constraint.HasType(meta, l, t)
    | constraint500

  constraint500 =
    | n:name                          -> Constraint.Variable(meta, n)
    | n:atom                          -> Constraint.Global(meta, n)
    | l:literal                       -> Constraint.Lit(l)
    | s<"("> c:constraint s<")">      -> Constraint.Parens(meta, c)


  // -- Statement
  statement =
    | letStatement
    | factStatement
    | forgetStatement
    | gotoStatement
    | callStatement
    | simulateStatement
    | e:expression    -> Statement.Expr(e)

  letStatement =
    | let_ n:name s<"="> e:expression
      -> Statement.Let(meta, n, e)
  
  factStatement =
    | fact_ s:logicSignature<primaryExpression> 
      -> Statement.Fact(meta, s)
  
  forgetStatement =
    | forget_ s:logicSignature<primaryExpression>
      -> Statement.Forget(meta, s)

  gotoStatement =
    | goto_ n:atom  -> Statement.Goto(meta, n)

  callStatement =
    | call_ n:atom  -> Statement.Call(meta, n)

  simulateStatement =
    | simulate_ for_ e:expression until_ g:simulateGoal s:signal*
      -> Statement.SimulateGlobal(meta, e, g, s)

  simulateGoal =
    | action_ quiescence_ -> SimulationGoal.ActionQuiescence(meta)
    | event_ quiescence_  -> SimulationGoal.EventQuiescence(meta)
    | quiescence_         -> SimulationGoal.TotalQuiescence(meta)
    | p:predicate         -> SimulationGoal.CustomGoal(meta, p)

  signal =
    | on_ s:signature<parameter> b:statementBlock<statement>
      -> Signal(meta, s, b)

  // -- Expressions
  expression =
    | searchExpression
    | pipeExpression

  searchExpression =
    | search_ p:predicate
      -> Expression.Search(meta, p)

  expressionBlock =
    | b:statementBlock<statement> -> Expression.Block(meta, b)

  pipeExpression =
    | l:pipeExpression s<"|"> r:invokeInfixExpression
      -> Expression.Pipe(meta, l, r)
    | invokeInfixExpression

  invokeInfixExpression =
    | l:invokeInfixExpression op:infix_symbol r:invokeMixfix
      -> Expression.Invoke(meta, Signature.Binary(meta, op, l, r))
    | invokeMixfix

  invokeMixfix =
    | s:castExpression ps:signaturePair<invokePostfix>+
      -> Expression.Invoke(meta, Signature.Keyword(meta, s, ps))
    | ps:signaturePair<invokePostfix>+
      -> Expression.Invoke(meta, Signature.KeywordSelfless(meta, ps))
    | castExpression

  castExpression =
    | s:invokePostfix as_ t:typeAppPrimary
      -> Expression.Cast(meta, t, s)
    | s:invokePostfix is_ t:typeAppPrimary
      -> Expression.HasType(meta, s, t)
    | s:invokePostfix s<"::"> r:name
      -> Expression.HasRole(meta, s, r)
    | invokePostfix

  invokePostfix =
    | s:invokePostfix n:atom
      -> Expression.Invoke(meta, Signature.Unary(meta, s, n))
    | applyExpression

  applyExpression =
    | f:applyExpression s<"("> xs:list1<expression, s<",">> s<")">
      -> Expression.Apply(meta, f, xs)
    | memberExpression

  memberExpression =
    | o:memberExpression s<"."> f:recordField<expression>
      -> Expression.Project(meta, o, f)
    | o:memberExpression s<"."> p:memberSelection
      -> Expression.Select(meta, o, p)
    | primaryExpression

  memberSelection =
    | s<"("> xs:list1<fieldSelection, s<",">> s<")">
      -> xs

  fieldSelection =
    | n:recordField<expression> as_ a:recordField<expression>
      -> Projection(meta, n, a)
    | n:recordField<expression>
      -> Projection(meta, n, n)

  primaryExpression =
    | matchSearchExpression
    | conditionExpression
    | forExpression
    | newExpression<expression>
    | x:interpolateText<expression> -> Expression.Interpolate(meta, x)
    | literalExpression
    | recordExpression<expression>
    | listExpression<expression>
    | expressionBlock
    | hole
    | self_                         -> Expression.Self(meta)
    | n:atom                        -> Expression.Global(meta, n)
    | n:name                        -> Expression.Variable(meta, n)
    | s<"("> e:expression s<")">    -> Expression.Parens(meta, e)

  conditionExpression =
    | condition_ cs:conditionCase+ end_
      -> Expression.Condition(meta, cs)

  conditionCase =
    | when_ e:expression b:statementBlock<statement>
      -> ConditionCase(meta, e, b)
    | always_ b:statementBlock<statement>
      -> ConditionCase(meta, Expression.Lit(Literal.True(meta)), b)

  matchSearchExpression =
    | match_ c:matchSearchCase+ end_
      -> Expression.MatchSearch(meta, c)

  matchSearchCase =
    | when_ p:predicate b:statementBlock<statement>
      -> MatchSearchCase(meta, p, b)
    | always_ b:statementBlock<statement>
      -> MatchSearchCase(meta, Predicate.Always(meta), b)

  forExpression =
    | for_ n:name in_ e:expression b:expressionBlock
      -> Expression.For(meta, e, n, b)

  newExpression<e> =
    | new_ n:atom fs:newFields<e>   -> Expression.New(meta, n, fs)

  newFields<e> =
    | s<"("> fs:list1<e, s<",">> s<")">    -> fs
    |                                      -> []

  listExpression<e> =
    | s<"["> xs:list0<e, s<",">> s<"]">
      -> Expression.List(meta, xs)

  recordExpression<e> =
    | s<"["> s<"->"> s<"]">                            -> Expression.Record(meta, [])
    | s<"["> xs:list1<recordPair<e>, s<",">> s<"]">    -> Expression.Record(meta, xs)

  recordPair<e> =
    | n:recordField<e> s<"->"> v:e -> Pair(meta, n, v)

  recordField<e> =
    | n:(name | atom)    -> RecordField.FName(n)
    | t:string           -> RecordField.FText(t)

  literalExpression =
    | l:literal             -> Expression.Lit(l)

  atomicExpression =
    | a:atom                                -> Expression.Global(meta, a)
    | newExpression<atomicExpression>
    | literalExpression
    | recordExpression<atomicExpression>
    | listExpression<atomicExpression>

  interpolateText<t> =
    | s<"\""> xs:interpolatePart<t>* "\""
      -> Interpolation(meta, xs)

  interpolatePart<p> =
    | "\\" c:any                 -> InterpolationPart.Escape(meta, c)
    | "[" x:s<p> s<"]">          -> InterpolationPart.Dynamic(meta, x)
    | ~"\"" c:any                -> InterpolationPart.Static(meta, c)


  // -- Literals
  literal =
    | text
    | integer
    | boolean

  boolean =
    | true_                 -> Literal.True(meta)
    | false_                -> Literal.False(meta)

  text =
    | x:string              -> Literal.Text(meta, x)

  integer =
    | x:s<t_integer>        -> Literal.Integer(meta, x)

  string =
    | x:s<t_text>           -> String(meta, x)
  
  hole =
    | x:s<"_"> ~name_rest   -> Expression.Hole(meta)

  // -- Token -> Rule & Basics
  atom =
    | s<"'"> x:t_atom               -> Name(meta, x)
    | ~reserved x:s<t_atom> ~":"    -> Name(meta, x)

  name = x:s<t_name>                          -> Name(meta, x)
  keyword = x:s<t_keyword>                    -> Name(meta, x)
  infix_symbol = x:s<t_infix_symbol>          -> Name(meta, x)
  not = x:not_                                -> Name(meta, x)
  and = x:and_                                -> Name(meta, x)
  or = x:or_                                  -> Name(meta, x)

  namespace = x:s<nonemptyListOf<t_atom, s<".">>>  -> Namespace(meta, x)


  // -- Higher-order
  logicSignature<t> =
    | s:t kws:signaturePair<t>+       -> Signature.Keyword(meta, s, kws)
    | s:t n:atom                      -> Signature.Unary(meta, s, n)

  signaturePair<t> =
    | kw:keyword v:t  -> Pair(meta, kw, v)

  partialLogicSignature<t> =
    | kws:signaturePair<t>+       -> PartialSignature.Keyword(meta, kws)
    | n:atom                      -> PartialSignature.Unary(meta, n)

  partialSignature<t> =
    | kws:signaturePair<t>+       -> PartialSignature.Keyword(meta, kws)
    | op:infix_symbol r:t         -> PartialSignature.Binary(meta, op, r)
    | n:atom                      -> PartialSignature.Unary(meta, n)
    | n:not                       -> PartialSignature.Unary(meta, n)

  signature<t> =
    | l:t op:infix_symbol r:t         -> Signature.Binary(meta, op, l, r)
    | s:t kws:signaturePair<t>+       -> Signature.Keyword(meta, s, kws)
    | s:t n:atom                      -> Signature.Unary(meta, s, n)
    | n:not s:t                       -> Signature.Unary(meta, s, n)
    | kws:signaturePair<t>+           -> Signature.KeywordSelfless(meta, kws)

  statementBlock<t> =
    | do_ xs:list0<t, s<";">> end_ -> xs

  list0<t, s> =
    | xs:listOf<t, s> s? -> xs

  list1<t, s> =
    | xs:nonemptyListOf<t, s> s? -> xs

  block<t> =
    | do_ xs:t* end_ -> xs

  s<p> = space* x:p -> x


  // -- Lexical
  token header (a file header) = space* "%" hs* "crochet" nl
  token hs = " " | "\t"
  token nl = "\n" | "\r"
  token line = (~nl any)*
  token comment (a comment) = "//" line
  space += comment

  token atom_start = "a".."z" | "-"
  token atom_rest = letter | digit | "-"
  token t_atom (an atom) = atom_start atom_rest*

  token t_keyword (a keyword) = t_atom ":"

  token name_start = "A".."Z" | "_"
  token name_rest = letter | digit | "-"
  token t_name (a name) = name_start name_rest*

  token t_infix_symbol =
    | x:t_any_infix ~infix_character  -> x
    | and_
    | or_

  token t_any_infix =
    | "++" | "+"
    | "-"
    | "*"
    | "/"
    | "<=" | "<"
    | ">=" | ">"
    | "===" | "=/="

  token infix_character = "+" | "-" | "*" | "/" | "<" | ">" | "="

  // -- Literals
  token dec_digit = "0".."9" | "_"

  token t_integer (an integer) =
    | ~"_" dec_digit+

  token text_character =
    | "\\" "\""
    | ~"\"" any

  token t_text (a text) =
    | "\"" text_character* "\""


  // -- Reserved words
  kw<w> = x:s<w> ~atom_rest -> x

  relation_ = kw<"relation">
  predicate_ = kw<"predicate">
  when_ = kw<"when">
  do_ = kw<"do">
  command_ = kw<"command">
  type_ = kw<"type">
  role_ = kw<"role">
  enum_ = kw<"enum">
  define_ = kw<"define">
  singleton_ = kw<"singleton">
  scene_ = kw<"scene">
  action_ = kw<"action">
  let_ = kw<"let">
  return_ = kw<"return">
  fact_ = kw<"fact">
  forget_ = kw<"forget">
  new_ = kw<"new">
  search_ = kw<"search">
  if_ = kw<"if">
  then_ = kw<"then">
  else_ = kw<"else">
  goto_ = kw<"goto">
  call_ = kw<"call">
  simulate_ = kw<"simulate">
  match_ = kw<"match">
  true_ = kw<"true">
  false_ = kw<"false">
  not_ = kw<"not">
  and_ = kw<"and">
  or_ = kw<"or">
  is_ = kw<"is">
  self_ = kw<"self">
  as_ = kw<"as">
  event_ = kw<"event">
  quiescence_ = kw<"quiescence">
  for_ = kw<"for">
  until_ = kw<"until">
  in_ = kw<"in">
  foreign_ = kw<"foreign">
  on_ = kw<"on">
  always_ = kw<"always">
  condition_ = kw<"condition">
  end_ = kw<"end">
  prelude_ = kw<"prelude">
  with_ = kw<"with">
  tags_ = kw<"tags">
  rank_ = kw<"rank">

  reserved =
    | relation_ | predicate_ | when_ | do_ | command_ | scene_ | action_
    | type_ | role_ | enum_ | define_ | singleton_ | goto_ | call_
    | let_ | return_ | fact_ | forget_ | new_ | search_ | if_ | simulate_
    | true_ | false_ | not_ | and_ | or_ | is_ | self_ | as_
    | event_ | quiescence_ | for_ | until_ | in_ | foreign_ | on_
    | always_ | match_ | then_ | else_ | condition_ | end_ | prelude_ | with_
    | tags_ | rank_
}