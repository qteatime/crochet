% soma

type Program(
  filename: text,
  source: text,
  declarations: Declaration[],
  metadata: MetadataPair[],
);

type Metadata(id: unsigned-integer32);
type MetadataPair(id: unsigned-integer32, range: SourceRange);
type SourceRange(start: unsigned-integer32, stop: unsigned-integer32);

// Declaration language
union Declaration {
  Do(meta: Metadata, body: Expression[]);

  Relation(
    meta: Metadata,
    name: text,
    type: TreeType,
    documentation: text,
  );

  ForeignCommand(
    meta: Metadata,
    name: text,
    types: Type[],
    foreign-name: text,
    parameters: text[],
    arguments: text[],
    contract: Contract,
    documentation: text,
  );

  CrochetCommand(
    meta: Metadata,
    name: text,
    parameters: text[],
    types: Type[],
    body: Expression[],
    contract: Contract,
    documentation: text,
  );

  Type(
    meta: Metadata,
    local: boolean,
    parent: Type?,
    name: text,
    fields: TypeField[],
    documentation: text,
  );

  Define(
    meta: Metadata,
    local: boolean,
    name: text,
    value: Expression,
    documentation: text,
  );

  Scene(
    meta: Metadata,
    name: text,
    body: Expression[],
    documentation: text,
  );

  Action(
    meta: Metadata,
    name: text,
    types: Type[],
    predicate: Predicate,
    rank: Expression,
    body: Expression[],
    documentation: text,
  );

  When(
    met: Metadata,
    predicate: Predicate,
    body: Expression[],
    documentation: text,
  );

  ForeignType(
    meta: Metadata,
    local: boolean,
    name: text,
    foreign-name: text,
    documentation: text,
  );

  SealType(
    meta: Metadata,
    name: text
  );

  Context(
    meta: Metadata,
    name: text,
    declarations: Declaration[],
    documentation: text,
  );

  Open(
    meta: Metadata,
    package: text
  );

  Test(
    meta: Metadata,
    title: text,
    body: Expression[]
  );
}

// Types
union Type {
  Local(name: text);
  Qualified(package: text, name: text);
  Static(type: Type);
}

type TypeField(parameter: text, type: Type);

type Contract(pre: ContractCondition[], post: ContractCondition[]);

type ContractCondition(meta: Metadata, tag: text, expression: Expression);

// Logic
union TreeType {
  One(next: TreeType);
  Many(next: TreeType);
  End();
}

union Predicate {
  Constraint(predicate: Predicate, constraint: Expression);
  And(left: Predicate, right: Predicate);
  Or(left: Predicate, right: Predicate);
  Has(name: text, patterns: Pattern[]);
  Not(predicate: Predicate);
  Let(name: text, expression: Expression);
  LetType(name: text, type: Type);
  Sample(size: unsigned-integer32, pool: PredicateSamplingPool);
  Always();
}

union PredicateSamplingPool {
  Relation(name: text, patterns: Pattern[]);
  Type(name: text, type: Type);
}

union Pattern {
  Type(meta: Metadata, pattern: Pattern, type: Type);
  Literal(lit: Literal);
  Global(meta: Metadata, name: text);
  Self(meta: Metadata);
  Variable(meta: Metadata, name: text);
  Wildcard();
}

// Expressions
union Literal {
  False();
  True();
  Text(value: text);
  Integer(value: integer);
  Float(value: float64);
  Nothing();
}

union Expression {
  Block(meta: Metadata, body: Expression[]);

  Literal(lit: Literal);
  Lambda(meta: Metadata, parameters: text[], body: Expression[]);
  List(meta: Metadata, values: Expression[]);
  Interpolate(meta: Metadata, parts: InterpolationPart[]);
  Record(meta: Metadata, pairs: RecordPair[]);

  IntrinsicEqual(meta: Metadata, left: Expression, right: Expression);
  HasType(meta: Metadata, value: Expression, type: Type);

  Variable(meta: Metadata, name: text);
  Global(meta: Metadata, name: text);
  Self(meta: Metadata);
  Return(meta: Metadata);
  StaticType(meta: Metadata);

  Search(meta: Metadata, predicate: Predicate);

  Apply(meta: Metadata, function: Expression, arguments: PartialExpression[]);
  Invoke(meta: Metadata, name: text, arguments: Expression[]);
  Partial(meta: Metadata, name: string, values: PartialExpression[]);
  New(meta: Metadata, name: text, arguments: Expression[]);
  
  Project(meta: Metadata, object: Expression, field: RecordField);
  ProjectMany(meta: Metadata, object: Expression, fields: Selection[]);

  Forall(meta: Metadata, expression: ForallExpression);
  MatchSearch(meta: Metadata, cases: MatchSearchCase[]);
  Condition(meta: Metadata, cases: ConditionCase[]);

  Lazy(meta: Metadata, value: Expression);
  Force(meta: Metadata, value: Expression);
} 

union PartialExpression {
  Hole();
  Concrete(expr: Expression);
}

union InterpolationPart {
  Static(content: text);
  Dynamic(expr: Expression);
}

union RecordField {
  Static(name: string);
  Dynamic(name: Expression);
}

union ForallExpression {
  Map(name: string, stream: Expression, body: ForallExpression);
  If(condition: Expression, body: ForallExpression);
  Do(body: Expression);
}

type MatchSearchCase(predicate: Predicate, body: Expression[]);
type ConditionCase(test: Expression, body: Expression[]);

type Selection(key: RecordField, alias: RecordField);
type RecordPair(key: RecordField, value: Expression);