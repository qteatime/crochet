type CModule(
  info: Interval,
  declarations: CDecl[]
)

type CDecl =
  | Define(info: Interval, name: Text, value: CExpr)
  | Type(info: Interval, declaration: CType_Decl)
  | Method(info: Interval, signature: CSignature, value: CExpr)


// -- Method
type CSignature =
  | As(info: Interval, param: CParam, xtype: CType)
  | Unary(info: Interval, name: Text, input: CParam, output: CType)
  | Binary(info: Interval, name: Text, left: CParam, right: CParam, output: CType)
  | Keyword(info: Interval, receiver: CParam, keywords: CKeyword_Part[], output: CType)
  | Selfless_Keyword(info: Interval, keywords: CKeyword_Part[], output: CType)

type CParam =
  | Typed(info: Interval, name: Text, xtype: CType)
  | Untyped(info: Interval, name: Text)
  | Unnamed(info: Interval, xtype: CType)

type CKeyword_Part(info: Interval, keyword: Text, param: CParam)

type CESignature =
  | As(info: Interval, value: CExpr, xtype: CType)
  | Unary(info: Interval, name: Text, input: CExpr)
  | Binary(info: Interval, name: Text, left: CExpr, right: CExpr)
  | Keyword(info: Interval, receiver: CExpr, keywords: CEKeyword_Part[])
  | Selfless_Keyword(info: Interval, keywords: CEKeyword_Part[])

type CEKeyword_Part(info: Interval, keyword: Text, value: CExpr)

// -- Type
type CType_Decl =
  | Void(info: Interval, modifier: CType_Mod, name: Text)
  | Record(info: Interval, name: Text, fields: CType_Field[])
  | Union(info: Interval, name: Text, subtypes: CType_Decl[])

type CType_Field(info: Interval, name: Text, xtype: CType)

type CType_Mod =
  | Abstract()
  | Singleton()

type CType =
  | Ref(info: Interval, ref: CTyperef)
  | Unknown(info: Interval)
  | Static(info: Interval, xtype: CType)
  | Exact(info: Interval, xtype: CType)

type CTyperef =
  | Named(info: Interval, names: Text[])
  | Namespaced(info: Interval, space: Text[], names: Text[])

// -- Expr
type CExpr =
  | Const(info: Interval, value: CConst)
  | Global(info: Interval, space: (Text[])?, name: Text)

  | Type(info: Interval, xtype: CType)
  | Has_Type(info: Interval, value: CExpr, xtype: CType)
  | New(info: Interval, struct: CTyperef, fields: CExpr[])
  | New_Named(info: Interval, struct: CTyperef, fields: CField_Expr[])
  | New_Extend(info: Interval, value: CExpr, struct: CTyperef, fields: CField_Expr[])
  | Project(info: Interval, value: CExpr, field: Text)

  | Block(info: Interval, exprs: CExpr[])
  | Let(info: Interval, name: Text, xtype: Type?, value: CExpr)
  | Variable(info: Interval, name: Text)
  | Invoke(info: Interval, signature: CESignature)
  | Self(info: Interval)

  | List(info: Interval, values: CExpr[])
  | Cons(info: Interval, head: CExpr[], tail: CExpr)

type CField_Expr(info: Interval, name: Text, value: CExpr)

type CConst =
  | Int(info: Interval, value: Integer)
  | Bool(info: Interval, value: Boolean)
  | Float(info: Interval, value: Float_64bit)
  | Text(info: Interval, value: Text)
  | Nothing(info: Interval)


grammar Crochet_Grammar : Module {
  Module =
    | header xs:Declaration* end                                                -> CModule(meta, xs)

  Declaration =
    | DDefine
    | DType
    | DMethod


  // == GLOBALS ================================================================
  DDefine =
    | define_ n:name "=" e:EBasic ";"                                           -> CDecl.Define(meta, n, e)


  // == Types ==================================================================
  DType =
    | abstract_ n:name ";"                                                      -> CType_Decl.Void(meta, CType_Mod.Abstract(), n)
    | singleton_ n:name ";"                                                     -> CType_Decl.Void(meta, CType_Mod.Singleton(), n)
    | type_ n:name "(" fs:CommaList<TypeField> ")" ";"                          -> CType_Decl.Record(meta, n, fs)
    | union_ n:name "{" xs:DType* "}"                                           -> CType_Decl.Union(meta, n, xs)

  TypeField =
    | n:name t:TFSuffix                                                         -> CType_Field(meta, n, t)

  TFSuffix =
    | is_ t:Type                                                                -> t
    |                                                                           -> CType.Unknown(meta)


  Type =
    | TPrefix

  TPrefix =
    | "#" t:TPrim                                                               -> CType.Static(meta, t)
    | "=" t:TPrim                                                               -> CType.Exact(meta, t)
    | TPrim

  TPrim =
    | x:Typeref                                                                 -> CType.Ref(meta, x)
    | "(" t:Type ")"                                                            -> t

  TNs = NonemptyListOf<name, ".">

  Typeref =
    | s:TNs "/" n:TNs                                                           -> CTyperef.Namespaced(meta, s, n)
    | n:TNs                                                                     -> CTyperef.Named(meta, n)


  // == METHODS ================================================================
  DMethod =
    | command_ s:DMSignature e:DMBody                                           -> CDecl.Method(meta, s, e)

  DMBody =
    | e:EDo                                                                     -> e
    | "=" e:EBasic ";"                                                          -> e

  DMSignature =
    | p:DMParam n:name rt:DMRet                                                 -> CSignature.Unary(meta, n, p, rt)
    | op:prefix_op p:DMParam rt:DMRet                                           -> CSignature.Unary(meta, op, p, rt)
    | l:DMParam op:binary_op r:DMParam rt:DMRet                                 -> CSignature.Binary(meta, op, l, r, rt)
    | s:DMParam kws:DMSigKeyword+ rt:DMRet                                      -> CSignature.Keyword(meta, s, kws, rt)
    | kws:DMSigKeyword+ rt:DMRet                                                -> CSignature.Selfless_Keyword(meta, kws, rt)
    | p:DMParam op:as_ t:Type                                                   -> CSignature.As(meta, op, p, t)

  DMParam =
    | "(" n:variable is_ t:Type ")"                                             -> CParam.Typed(meta, n, t)
    | n:variable                                                                -> CParam.Untyped(meta, n)
    | t:Type                                                                    -> CParam.Unnamed(meta, t)

  DMRet =
    | "->" t:Type                                                               -> t
    |                                                                           -> CType.Unknown(meta)

  DMSigKeyword =
    | kw:keyword p:DMParam                                                      -> CKeyword_Part(meta, kw, p)

  // == EXPRESSIONS ============================================================
  Expr =
    | let_ n:variable t:ELetType "=" e:EBasic                                   -> CExpr.Let(meta, n, t, e)
    | EDo
    | EBasic

  ELetType =
    | is_ t:Type                                                                -> t
    |                                                                           -> null

  EDo =
    | do_ xs:NonemptyListOf<Expr, ";"> ";"? end_                                -> CExpr.Block(meta, xs)

  EBasic =
    | EInvokeMixfix

  EInvokeMixfix =
    | s:EInvokeInfix ps:EKeywordPair+                                           -> CExpr.Invoke(meta, CESignature.Keyword(meta, s, ps))
    | ps:EKeywordPair+                                                          -> CExpr.Invoke(meta, CESignature.Selfless_Keyword(meta, ps))
    | EInvokeInfix

  EKeywordPair =
    | kw:keyword e:EInvokeInfix                                                 -> CEKeyword_Part(meta, kw, e)

  EInvokeInfix =
    | l:EInvokePrePost op:binary_op r:EInvokePrePost                            -> CExpr.Invoke(meta, CESignature.Binary(meta, op, l, r))
    | l:EInvokePrePost op:as_ t:Type                                            -> CExpr.Invoke(meta, CESignature.As(meta, l, t))
    | v:EInvokePrePost is_ t:Type                                               -> CExpr.Has_Type(meta, v, t)
    | EInvokePrePost

  EInvokePrePost =
    | EInvokePrefix
    | EInvokePostfix

  EInvokePrefix =
    | op:prefix_op e:EInvokePostfix                                             -> CExpr.Invoke(meta, CESignature.Unary(meta, op, e))
    
  EInvokePostfix =
    | e:EInvokePostfix n:name                                                   -> CExpr.Invoke(meta, CESignature.Unary(meta, n, e))
    | EMember

  EMember =
    | o:EMember "." p:name                                                      -> CExpr.Project(meta, o, p)
    | EPrim

  ENew =
    | new_ r:Typeref "(" e:EPrim with_ xs:CommaList1<FieldExpr> ")"             -> CExpr.New_Extend(meta, e, r, xs)
    | new_ r:Typeref "(" xs:CommaList<FieldExpr> ")"                            -> CExpr.New_Named(meta, r, xs)
    | new_ r:Typeref "(" xs:CommaList<Expr> ")"                                 -> CExpr.New(meta, r, xs)

  FieldExpr =
    | a:name "->" v:EBasic                                                      -> CField_Expr(meta, a, v)


  EPrim =
    | self_                                                                     -> CExpr.Self(meta)
    | s:TNs "/" a:name                                                          -> CExpr.Global(meta, s, a)
    | a:name                                                                    -> CExpr.Global(meta, null, a)
    | v:variable                                                                -> CExpr.Variable(meta, v)
    | l:literal                                                                 -> CExpr.Const(meta, l)
    | "#" t:TPrim                                                               -> CExpr.Type(meta, t)
    | x:ENew                                                                    -> x
    | x:EList                                                                   -> x
    | "(" e:Expr ")"                                                            -> e

  EList =
    | "[" xs:NonemptyListOf<Expr, ","> "," "..." t:Expr "]"                     -> CExpr.Cons(meta, xs, t)
    | "[" xs:CommaList<Expr> "]"                                                -> CExpr.List(meta, xs)


  // == CONSTANTS ==============================================================
  literal =
    | x:float                                                                   -> CConst.Float(meta, x)
    | x:integer                                                                 -> CConst.Int(meta, x)
    | x:boolean                                                                 -> CConst.Bool(meta, x)
    | x:text                                                                    -> CConst.Text(meta, x)
    | nothing_                                                                  -> CConst.Nothing(meta)


  // == HIGHER-ORDER ===========================================================
  CommaList<T> =
    | xs:ListOf<T, ","> ","?            -> xs

  CommaList1<T> =
    | xs:NonemptyListOf<T, ","> ","?    -> xs

  // == LEXICAL ================================================================
  token header (a file header) =
    | "%" hs* "crochet/1" 

  token line =
    | (~newline any)*

  token hs =
    | " " | "\t"

  token newline =
    | "\r\n" | "\r" | "\n"

  token comment (a comment) =
    | "//" line

  space += comment


  // -- Names ------------------------------------------------------------------
  token atom_start = "a".."z"
  token atom_rest = "a".."z" | "-" | "0".."9"
  token atom (an atom) = atom_start atom_rest*

  token variable_start = "A".."Z"
  token variable_rest = "A".."Z" | "a".."z" | "-" | "0".."9"
  token variable (a variable) =
    | variable_start variable_rest*
    | "_"

  name (a name) = ~reserved n:atom ~":" -> n
  token keyword (a keyword) = atom ":"


  // -- Boolean ----------------------------------------------------------------
  boolean =
    | b:t_boolean   -> @parse_boolean(b)

  token t_boolean =
    | true_
    | false_


  // -- Numbers ----------------------------------------------------------------
  token dec_digit = "0".."9" | "_"
  token hex_digit = "0".."9" | "a".."f" | "A".."F"
  token ehex_digit = hex_digit | "_"

  token t_integer (an integer) =
    | ~"_" "0x" ehex_digit+
    | ~"_" "-"? dec_digit+

  integer = x:t_integer -> @parse_integer(x)

  token t_float (a floating point number) =
    | ~"_" "-"? dec_digit+ "." dec_digit+

  float = x:t_float -> @parse_float(x)


  // -- Text -------------------------------------------------------------------
  token text_character =
    | "\\" escape_sequence
    | ~("\"" | "[" | "]") any

  token escape_sequence =
    | "u" hex_digit hex_digit hex_digit hex_digit
    | "x" hex_digit hex_digit
    | any

  token t_text (a text) =
    | "\"" text_character* "\""
  
  text = x:t_text -> @parse_text(x)


  // -- Operators --------------------------------------------------------------
  token binary_op (a binary operator) =
    | t_binary_op ~(symbol | atom_rest)
    | and_
    | or_

  token symbol =
    | "+" | "-" | ">" | "<" | "*" | "=" | "|" | "^" | "~" | "!" | "@" | "#" | "%" | "&"

  token t_binary_op =
    | "++" | "+"
    | "-" | "->"
    | "<-" | "<<" | "<=" | "<"
    | ">>" | ">=" | ">"
    | "===" | "=/="
    | "**" | "*"
    | "%"
    | "/"

  token prefix_op =
    | not_

  
  // -- Special tokens ---------------------------------------------------------
  kw<w> = x:w ~(atom_rest | ":") -> x

  define_ = kw<"define">
  command_ = kw<"command">
  abstract_ = kw<"abstract">
  singleton_ = kw<"singleton">
  type_ = kw<"type">
  union_ = kw<"union">
  self_ = kw<"self">
  is_ = kw<"is">
  not_ = kw<"not">
  and_ = kw<"and">
  or_ = kw<"or">
  true_ = kw<"true">
  false_ = kw<"false">
  new_ = kw<"new">
  do_ = kw<"do">
  end_ = kw<"end">
  let_ = kw<"let">
  as_ = kw<"as">
  static_ = kw<"static">
  foreign_ = kw<"foreign">
  with_ = kw<"with">
  nothing_ = kw<"nothing">

  reserved =
    | define_
    | command_
    | abstract_ | singleton_ | type_ | union_
    | is_
    | not_ | or_ | and_
    | true_ | false_
    | self_
    | new_
    | do_ | end_
    | let_
    | as_
    | static_
    | foreign_
    | with_
    | nothing_
}